


<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="es-UN" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="es-UN" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Dimensión Efectiva de las Redes Neuronales de Qiskit &mdash; documentación de Qiskit Machine Learning - 0.4.0</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <!-- <link rel="stylesheet" href="../_static/pygments.css" type="text/css" /> -->
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/jupyter-sphinx.css" type="text/css" />
  <link rel="stylesheet" href="../_static/thebelab.css" type="text/css" />
  <link rel="stylesheet" href="../_static/panels-bootstrap.5fd3999ee7762ccc51105388f4a9d115.css" type="text/css" />
  <link rel="stylesheet" href="../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" type="text/css" />
  <link rel="stylesheet" href="../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" type="text/css" />
  <link rel="stylesheet" href="../_static/style.css" type="text/css" />
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  <link rel="stylesheet" href="../_static/gallery.css" type="text/css" />
    <link rel="index" title="Índice" href="../genindex.html" />
    <link rel="search" title="Buscar" href="../search.html" />
    <link rel="next" title="Release Notes" href="../release_notes.html" />
    <link rel="prev" title="Guardar, Cargar modelos de Machine Learning de Qiskit y Entrenamiento Continuo" href="09_saving_and_loading%20models.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<div class="container-fluid header-holder tutorials-header" id="header-holder">
  <div class="container">
    <div class="header-container">
      <a class="header-logo" href="https://qiskit.org/" aria-label="PyTorch"></a>

      <div class="main-menu">
        <ul>
          <li>
            <a href="../getting_started.html">Getting started</a>
          </li>

          <li>
            <a href="https://qiskit.org/documentation/machine-learning/tutorials/index.html" target="_blank">Tutorials</a>
          </li>

          <li>
            <a href="https://qiskit.org/documentation/partners/" target="_blank">Partners</a>
          </li>

          <li>
            <div id="resourcesDropdownButton" data-toggle="resources-dropdown" class="resources-dropdown">
              <a class="resource-option with-down-orange-arrow">
                Applications
              </a>
              <div class="resources-dropdown-menu">
                <a class="nav-dropdown-item" href="https://qiskit.org/documentation/machine-learning/">
                  <span class="dropdown-title">Machine learning</span>
                  <p>QSVM, VQC (Variational Quantum Classifier), and QGAN (Quantum Generative
                    Adversarial Network) algorithms.</p>
                </a>
                <a class="nav-dropdown-item" href="https://qiskit.org/documentation/nature/">
                  <span class="dropdown-title">Nature</span>
                  <p>Quantum applications in chemistry, physics, and biology.</p>
                </a>
                <a class="nav-dropdown-item" href="https://qiskit.org/documentation/finance/">
                  <span class="dropdown-title">Finance</span>
                  <p>Uncertainty components for stock/securities problems, Ising translators for
                    portfolio optimizations and data providers to source real or random data.</p>
                </a>
                <a class="nav-dropdown-item" href="https://qiskit.org/documentation/optimization/">
                  <span class="dropdown-title">Optimization</span>
                  <p>High-level optimization problems that are ready to
                    run on simulators and real quantum devices</p>
                </a>
              </div>
          </li>
          <li>
              <a href="https://qiskit.org/documentation/experiments/" target="_blank">Experiments</a>
          </li>
          <li>
            <div id="resourcesDropdownButton" data-toggle="resources-dropdown" class="resources-dropdown">
              <a class="resource-option with-down-orange-arrow">
                Resources
              </a>
              <div class="resources-dropdown-menu">
                <a class="doc-dropdown-option nav-dropdown-item" href="https://qiskit.slack.com">
                  <span class="dropdown-title">Slack support</span>
                  <p></p>
                </a>
                <a class="doc-dropdown-option nav-dropdown-item" href="https://qiskit.org/textbook">
                  <span class="dropdown-title">Qiskit Textbook</span>
                  <p></p>
                </a>
                <a class="doc-dropdown-option nav-dropdown-item" href="https://qiskit.org/events">
                  <span class="dropdown-title">Qiskit events</span>
                  <p></p>
                </a>
            </div>
          </li>
          <li>
            <a href="https://github.com/Qiskit/qiskit-machine-learning" target="_blank">Github</a>
          </li>
        </ul>
      </div>

      <a class="main-menu-open-button" href="#" data-behavior="open-mobile-menu"></a>
    </div>

  </div>
</div>


<body class="pytorch-body">

   

    

    <div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    <span class="rst-current-version-label">Spanish</span>
    <span class="rst-versions-dropdown-icon"></span>
  </span>
  <div class="rst-other-versions">
    
    <dl>
      <dt>Idiomas</dt>
      
        <dd><a class="version" href="/documentation/machine-learning/tutorials/10_effective_dimension.html">English</a></dd>
      
        <dd><a class="version" href="/documentation/machine-learning/locale/bn_BN/tutorials/10_effective_dimension.html">Bengali</a></dd>
      
        <dd><a class="version" href="/documentation/machine-learning/locale/fr_FR/tutorials/10_effective_dimension.html">French</a></dd>
      
        <dd><a class="version" href="/documentation/machine-learning/locale/hi_IN/tutorials/10_effective_dimension.html">Hindi</a></dd>
      
        <dd><a class="version" href="/documentation/machine-learning/locale/it_IT/tutorials/10_effective_dimension.html">Italian</a></dd>
      
        <dd><a class="version" href="/documentation/machine-learning/locale/ja_JP/tutorials/10_effective_dimension.html">Japanese</a></dd>
      
        <dd><a class="version" href="/documentation/machine-learning/locale/ko_KR/tutorials/10_effective_dimension.html">Korean</a></dd>
      
        <dd><a class="version" href="/documentation/machine-learning/locale/ml_IN/tutorials/10_effective_dimension.html">Malayalam</a></dd>
      
        <dd><a class="version" href="/documentation/machine-learning/locale/ru_RU/tutorials/10_effective_dimension.html">Russian</a></dd>
      
        <dd><a class="version" href="/documentation/machine-learning/locale/es_UN/tutorials/10_effective_dimension.html">Spanish</a></dd>
      
        <dd><a class="version" href="/documentation/machine-learning/locale/ta_IN/tutorials/10_effective_dimension.html">Tamil</a></dd>
      
        <dd><a class="version" href="/documentation/machine-learning/locale/tr_TR/tutorials/10_effective_dimension.html">Turkish</a></dd>
      
        <dd><a class="version" href="/documentation/machine-learning/locale/vi_VN/tutorials/10_effective_dimension.html">Vietnamese</a></dd>
      
    </dl>
    
  </div>
  <script>
    jQuery('.version').click((evt) => {
      const hash = window.location.hash
      const complete_url = evt.target.href + hash
      window.location = complete_url
      evt.preventDefault()
    })
  </script>
</div>

    <div class="table-of-contents-link-wrapper">
      <span>Table of Contents</span>
      <a href="#" class="toggle-table-of-contents" data-behavior="toggle-table-of-contents"></a>
    </div>

    <nav data-toggle="wy-nav-shift" class="pytorch-left-menu" id="pytorch-left-menu">
      <div class="pytorch-side-scroll">
        <div class="pytorch-menu pytorch-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          <div class="pytorch-left-menu-search">
            

            
              
              
                <div class="version">
                  0.4.0
                </div>
              
            

            


  


<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search Docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

            
          </div>

          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../getting_started.html">Primeros Pasos</a></li>
<li class="toctree-l1"><a class="reference internal" href="../apidocs/qiskit_machine_learning.html">Referencias de la API</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Tutoriales</a></li>
<li class="toctree-l1"><a class="reference internal" href="../release_notes.html">Notas de la Versión</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <div class="pytorch-container">
      <div class="pytorch-page-level-bar" id="pytorch-page-level-bar">
        <div class="pytorch-breadcrumbs-wrapper">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="pytorch-breadcrumbs">
    
      <li>
        <a href="../index.html">
          
            Docs
          
        </a> &gt;
      </li>

        
          <li><a href="index.html">Tutoriales de Machine Learning</a> &gt;</li>
        
      <li>Dimensión Efectiva de las Redes Neuronales de Qiskit</li>
    
    
      <li class="pytorch-breadcrumbs-aside">
        
            
            <a href="../_sources/tutorials/10_effective_dimension.ipynb.txt" rel="nofollow"><img src="../_static/images/view-page-source-icon.svg"></a>
          
        
      </li>
    
  </ul>

  
</div>
        </div>

        <div class="pytorch-shortcuts-wrapper" id="pytorch-shortcuts-wrapper">
          Shortcuts
        </div>
      </div>

      <section data-toggle="wy-nav-shift" id="pytorch-content-wrap" class="pytorch-content-wrap">
        <div class="pytorch-content-left">
          
          <div class="rst-content">
          
            <div role="main" class="main-content" itemscope="itemscope" itemtype="http://schema.org/Article">
             <article itemprop="articleBody" id="pytorch-article" class="pytorch-article">
              
  
<style>
/* CSS for nbsphinx extension */

/* remove conflicting styling from Sphinx themes */
div.nbinput.container div.prompt *,
div.nboutput.container div.prompt *,
div.nbinput.container div.input_area pre,
div.nboutput.container div.output_area pre,
div.nbinput.container div.input_area .highlight,
div.nboutput.container div.output_area .highlight {
    border: none;
    padding: 0;
    margin: 0;
    box-shadow: none;
}

div.nbinput.container > div[class*=highlight],
div.nboutput.container > div[class*=highlight] {
    margin: 0;
}

div.nbinput.container div.prompt *,
div.nboutput.container div.prompt * {
    background: none;
}

div.nboutput.container div.output_area .highlight,
div.nboutput.container div.output_area pre {
    background: unset;
}

div.nboutput.container div.output_area div.highlight {
    color: unset;  /* override Pygments text color */
}

/* avoid gaps between output lines */
div.nboutput.container div[class*=highlight] pre {
    line-height: normal;
}

/* input/output containers */
div.nbinput.container,
div.nboutput.container {
    display: -webkit-flex;
    display: flex;
    align-items: flex-start;
    margin: 0;
    width: 100%;
}
@media (max-width: 540px) {
    div.nbinput.container,
    div.nboutput.container {
        flex-direction: column;
    }
}

/* input container */
div.nbinput.container {
    padding-top: 5px;
}

/* last container */
div.nblast.container {
    padding-bottom: 5px;
}

/* input prompt */
div.nbinput.container div.prompt pre {
    color: #307FC1;
}

/* output prompt */
div.nboutput.container div.prompt pre {
    color: #BF5B3D;
}

/* all prompts */
div.nbinput.container div.prompt,
div.nboutput.container div.prompt {
    width: 4.5ex;
    padding-top: 5px;
    position: relative;
    user-select: none;
}

div.nbinput.container div.prompt > div,
div.nboutput.container div.prompt > div {
    position: absolute;
    right: 0;
    margin-right: 0.3ex;
}

@media (max-width: 540px) {
    div.nbinput.container div.prompt,
    div.nboutput.container div.prompt {
        width: unset;
        text-align: left;
        padding: 0.4em;
    }
    div.nboutput.container div.prompt.empty {
        padding: 0;
    }

    div.nbinput.container div.prompt > div,
    div.nboutput.container div.prompt > div {
        position: unset;
    }
}

/* disable scrollbars on prompts */
div.nbinput.container div.prompt pre,
div.nboutput.container div.prompt pre {
    overflow: hidden;
}

/* input/output area */
div.nbinput.container div.input_area,
div.nboutput.container div.output_area {
    -webkit-flex: 1;
    flex: 1;
    overflow: auto;
}
@media (max-width: 540px) {
    div.nbinput.container div.input_area,
    div.nboutput.container div.output_area {
        width: 100%;
    }
}

/* input area */
div.nbinput.container div.input_area {
    border: 1px solid #e0e0e0;
    border-radius: 2px;
    /*background: #f5f5f5;*/
}

/* override MathJax center alignment in output cells */
div.nboutput.container div[class*=MathJax] {
    text-align: left !important;
}

/* override sphinx.ext.imgmath center alignment in output cells */
div.nboutput.container div.math p {
    text-align: left;
}

/* standard error */
div.nboutput.container div.output_area.stderr {
    background: #fdd;
}

/* ANSI colors */
.ansi-black-fg { color: #3E424D; }
.ansi-black-bg { background-color: #3E424D; }
.ansi-black-intense-fg { color: #282C36; }
.ansi-black-intense-bg { background-color: #282C36; }
.ansi-red-fg { color: #E75C58; }
.ansi-red-bg { background-color: #E75C58; }
.ansi-red-intense-fg { color: #B22B31; }
.ansi-red-intense-bg { background-color: #B22B31; }
.ansi-green-fg { color: #00A250; }
.ansi-green-bg { background-color: #00A250; }
.ansi-green-intense-fg { color: #007427; }
.ansi-green-intense-bg { background-color: #007427; }
.ansi-yellow-fg { color: #DDB62B; }
.ansi-yellow-bg { background-color: #DDB62B; }
.ansi-yellow-intense-fg { color: #B27D12; }
.ansi-yellow-intense-bg { background-color: #B27D12; }
.ansi-blue-fg { color: #208FFB; }
.ansi-blue-bg { background-color: #208FFB; }
.ansi-blue-intense-fg { color: #0065CA; }
.ansi-blue-intense-bg { background-color: #0065CA; }
.ansi-magenta-fg { color: #D160C4; }
.ansi-magenta-bg { background-color: #D160C4; }
.ansi-magenta-intense-fg { color: #A03196; }
.ansi-magenta-intense-bg { background-color: #A03196; }
.ansi-cyan-fg { color: #60C6C8; }
.ansi-cyan-bg { background-color: #60C6C8; }
.ansi-cyan-intense-fg { color: #258F8F; }
.ansi-cyan-intense-bg { background-color: #258F8F; }
.ansi-white-fg { color: #C5C1B4; }
.ansi-white-bg { background-color: #C5C1B4; }
.ansi-white-intense-fg { color: #A1A6B2; }
.ansi-white-intense-bg { background-color: #A1A6B2; }

.ansi-default-inverse-fg { color: #FFFFFF; }
.ansi-default-inverse-bg { background-color: #000000; }

.ansi-bold { font-weight: bold; }
.ansi-underline { text-decoration: underline; }


div.nbinput.container div.input_area div[class*=highlight] > pre,
div.nboutput.container div.output_area div[class*=highlight] > pre,
div.nboutput.container div.output_area div[class*=highlight].math,
div.nboutput.container div.output_area.rendered_html,
div.nboutput.container div.output_area > div.output_javascript,
div.nboutput.container div.output_area:not(.rendered_html) > img{
    padding: 5px;
    margin: 0;
}

/* fix copybtn overflow problem in chromium (needed for 'sphinx_copybutton') */
div.nbinput.container div.input_area > div[class^='highlight'],
div.nboutput.container div.output_area > div[class^='highlight']{
    overflow-y: hidden;
}

/* hide copybtn icon on prompts (needed for 'sphinx_copybutton') */
.prompt .copybtn {
    display: none;
}

/* Some additional styling taken form the Jupyter notebook CSS */
div.rendered_html table {
  border: none;
  border-collapse: collapse;
  border-spacing: 0;
  color: black;
  font-size: 12px;
  table-layout: fixed;
}
div.rendered_html thead {
  border-bottom: 1px solid black;
  vertical-align: bottom;
}
div.rendered_html tr,
div.rendered_html th,
div.rendered_html td {
  text-align: right;
  vertical-align: middle;
  padding: 0.5em 0.5em;
  line-height: normal;
  white-space: normal;
  max-width: none;
  border: none;
}
div.rendered_html th {
  font-weight: bold;
}
div.rendered_html tbody tr:nth-child(odd) {
  background: #f5f5f5;
}
div.rendered_html tbody tr:hover {
  background: rgba(66, 165, 245, 0.2);
}
</style>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Esta página fue generada a partir de <a class="reference external" href="https://github.com/Qiskit/qiskit-machine-learning/blob/stable/0.4/docs/tutorials/10_effective_dimension.ipynb">docs/tutorials/10_effective_dimension.ipynb</a>.</p>
</div>
<section id="Dimensión-Efectiva-de-las-Redes-Neuronales-de-Qiskit">
<h1>Dimensión Efectiva de las Redes Neuronales de Qiskit<a class="headerlink" href="#Dimensión-Efectiva-de-las-Redes-Neuronales-de-Qiskit" title="Enlazar permanentemente con este título">¶</a></h1>
<p>En este tutorial, aprovecharemos las clases <code class="docutils literal notranslate"><span class="pre">EffectiveDimension</span></code> y <code class="docutils literal notranslate"><span class="pre">LocalEffectiveDimension</span></code> para evaluar el poder de los modelos de redes neuronales cuánticas. Son métricas basadas en la geometría de la información que conectan con nociones como la entrenabilidad, la expresibilidad o la capacidad de generalización.</p>
<p>Antes de profundizar en el ejemplo de código, explicaremos brevemente cuál es la diferencia entre estas dos métricas y por qué son relevantes para el estudio de las redes neuronales cuánticas. Se puede encontrar más información sobre la dimensión efectiva global en <a class="reference external" href="https://arxiv.org/pdf/2011.00027.pdf">este artículo</a>, mientras que la dimensión efectiva local se introdujo en un <a class="reference external" href="https://arxiv.org/abs/2112.04807">trabajo posterior</a>.</p>
<section id="1.-Dimensión-Efectiva-Global-vs. Local">
<h2>1. Dimensión Efectiva Global vs. Local<a class="headerlink" href="#1.-Dimensión-Efectiva-Global-vs. Local" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Tanto el modelo de machine learning clásico como el cuántico comparten un objetivo común: ser bueno para <strong>generalizar</strong>, es decir, aprender información de los datos y aplicarla en datos ocultos.</p>
<p>Encontrar una buena métrica para evaluar esta capacidad no es un asunto trivial. En <a class="reference external" href="https://arxiv.org/pdf/2011.00027.pdf">The Power of Quantum Neural Networks</a>, los autores presentan la dimensión efectiva <strong>global</strong> como un indicador útil de qué tan bien un modelo en particular podrá desempeñarse con nuevos datos. En <a href="#id1"><span class="problematic" id="id2">``</span></a>Effective Dimension of Machine Learning Models &lt;<a class="reference external" href="https://arxiv.org/pdf/2112.04807.pdf">https://arxiv.org/pdf/2112.04807.pdf</a>&gt;`__, la dimensión efectiva <strong>local</strong> se propone como una nueva medida de capacidad que limita el error de generalización de los modelos de machine learning.</p>
<p>La diferencia clave entre la dimensión efectiva global (clase <code class="docutils literal notranslate"><span class="pre">EffectiveDimension</span></code>) y <strong>local</strong> (clase <code class="docutils literal notranslate"><span class="pre">LocalEffectiveDimension</span></code>) no está en la forma en que se calculan, sino en la naturaleza del espacio de parámetros que se analiza. La dimensión efectiva global incorpora el <strong>espacio de parámetros completo</strong> del modelo y se calcula a partir de una <strong>gran cantidad de conjuntos de parámetros (peso)</strong>. Por otro lado, la dimensión efectiva local se enfoca en qué tan bien el modelo <strong>entrenado</strong> puede generalizar a nuevos datos y qué tan <strong>expresiva</strong> puede ser. Por lo tanto, la dimensión efectiva local se calcula a partir de <strong>un solo</strong> conjunto de muestras de peso (resultado del entrenamiento). Esta diferencia es pequeña en términos de implementación práctica, pero bastante relevante a nivel conceptual.</p>
</section>
<section id="2.-El-Algoritmo-de-Dimensión-Efectiva">
<h2>2. El Algoritmo de Dimensión Efectiva<a class="headerlink" href="#2.-El-Algoritmo-de-Dimensión-Efectiva" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Los algoritmos de dimensión efectiva global y local utilizan la matriz de Información de Fisher para proporcionar una medida de la complejidad. Los detalles sobre cómo se calcula esta matriz se proporcionan en el <a class="reference external" href="https://arxiv.org/pdf/2011.00027.pdf">artículo de referencia</a>, pero en términos generales, esta matriz captura qué tan sensible es la salida de una red neuronal a los cambios en el espacio de parámetros de la red.</p>
<p>En particular, este algoritmo sigue 4 pasos principales:</p>
<ol class="arabic simple">
<li><p><strong>Simulación de Monte Carlo:</strong> los pasos hacia adelante y hacia atrás (gradientes) de la red neuronal se calculan para cada par de muestras de entrada y peso.</p></li>
<li><p><strong>Cálculo de Matriz de Fisher:</strong> estos resultados y gradientes se utilizan para calcular la Matriz de Información de Fisher.</p></li>
<li><p><strong>Normalización de la Matriz de Fisher:</strong> promediando todas las muestras de entrada y dividiendo por la traza de la matriz</p></li>
<li><p><strong>Cálculo de la Dimensión Efectiva:</strong> según la fórmula de <a class="reference external" href="https://arxiv.org/pdf/2011.00027.pdf">Abbas et al.</a></p></li>
</ol>
</section>
<section id="3.-Ejemplo-Básico-(CircuitQNN)">
<h2>3. Ejemplo Básico (CircuitQNN)<a class="headerlink" href="#3.-Ejemplo-Básico-(CircuitQNN)" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Este ejemplo muestra cómo configurar un problema de modelo QNN y ejecutar el algoritmo de dimensión efectiva global. Tanto <code class="docutils literal notranslate"><span class="pre">CircuitQNN</span></code> de Qiskit (que se muestra en este ejemplo) como <code class="docutils literal notranslate"><span class="pre">OpflowQNN</span></code> (que se muestra en un ejemplo posterior) se pueden usar con la clase <code class="docutils literal notranslate"><span class="pre">EffectiveDimension</span></code>.</p>
<p>Partimos de las importaciones requeridas y una semilla fija para el generador de números aleatorios con fines de reproducibilidad.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[1]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Necessary imports</span>
<span class="kn">from</span> <span class="nn">qiskit.circuit.library</span> <span class="kn">import</span> <span class="n">ZFeatureMap</span><span class="p">,</span> <span class="n">ZZFeatureMap</span><span class="p">,</span> <span class="n">RealAmplitudes</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">qiskit_machine_learning.neural_networks</span> <span class="kn">import</span> <span class="n">CircuitQNN</span><span class="p">,</span> <span class="n">TwoLayerQNN</span>
<span class="kn">from</span> <span class="nn">qiskit.utils</span> <span class="kn">import</span> <span class="n">QuantumInstance</span><span class="p">,</span> <span class="n">algorithm_globals</span>
<span class="kn">from</span> <span class="nn">qiskit</span> <span class="kn">import</span> <span class="n">Aer</span><span class="p">,</span> <span class="n">QuantumCircuit</span>

<span class="kn">from</span> <span class="nn">qiskit_machine_learning.neural_networks</span> <span class="kn">import</span> <span class="n">EffectiveDimension</span><span class="p">,</span> <span class="n">LocalEffectiveDimension</span>

<span class="kn">from</span> <span class="nn">qiskit_machine_learning.algorithms.classifiers</span> <span class="kn">import</span> <span class="n">NeuralNetworkClassifier</span><span class="p">,</span> <span class="n">VQC</span>
<span class="kn">from</span> <span class="nn">qiskit.algorithms.optimizers</span> <span class="kn">import</span> <span class="n">COBYLA</span>

<span class="kn">from</span> <span class="nn">IPython.display</span> <span class="kn">import</span> <span class="n">clear_output</span>

<span class="c1"># set random seed</span>
<span class="n">algorithm_globals</span><span class="o">.</span><span class="n">random_seed</span> <span class="o">=</span> <span class="mi">42</span>
</pre></div>
</div>
</div>
<section id="3.1-Definir-QNN">
<h3>3.1 Definir QNN<a class="headerlink" href="#3.1-Definir-QNN" title="Enlazar permanentemente con este título">¶</a></h3>
<p>El primer paso para crear un <code class="docutils literal notranslate"><span class="pre">CircuitQNN</span></code> es definir un mapa de características parametrizado y un ansatz. En este ejemplo de juguete, usaremos 3 qubits y definiremos el circuito usado en la clase <code class="docutils literal notranslate"><span class="pre">TwoLayerQNN</span></code>.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[2]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">num_qubits</span> <span class="o">=</span> <span class="mi">3</span>
<span class="c1"># create a feature map</span>
<span class="n">feature_map</span> <span class="o">=</span> <span class="n">ZFeatureMap</span><span class="p">(</span><span class="n">feature_dimension</span><span class="o">=</span><span class="n">num_qubits</span><span class="p">,</span> <span class="n">reps</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="c1"># create a variational circuit</span>
<span class="n">ansatz</span> <span class="o">=</span> <span class="n">RealAmplitudes</span><span class="p">(</span><span class="n">num_qubits</span><span class="p">,</span> <span class="n">reps</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># combine feature map and ansatz into a single circuit</span>
<span class="n">qc</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">num_qubits</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">feature_map</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_qubits</span><span class="p">))</span>
<span class="n">qc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ansatz</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_qubits</span><span class="p">))</span>
<span class="n">qc</span><span class="o">.</span><span class="n">decompose</span><span class="p">()</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s2">&quot;mpl&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[2]:
</pre></div>
</div>
<div class="output_area docutils container">
<img alt="../_images/tutorials_10_effective_dimension_6_0.png" src="../_images/tutorials_10_effective_dimension_6_0.png" />
</div>
</div>
<p>El circuito parametrizado se puede enviar junto con un mapa de interpretación opcional (paridad en este caso) al constructor <code class="docutils literal notranslate"><span class="pre">CircuitQNN</span></code>.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[3]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># parity maps bitstrings to 0 or 1</span>
<span class="k">def</span> <span class="nf">parity</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="s2">&quot;</span><span class="si">{:b}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s2">&quot;1&quot;</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span>


<span class="n">output_shape</span> <span class="o">=</span> <span class="mi">2</span>  <span class="c1"># corresponds to the number of classes, possible outcomes of the (parity) mapping.</span>
</pre></div>
</div>
</div>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[4]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># declare quantum instance</span>
<span class="n">qi_sv</span> <span class="o">=</span> <span class="n">QuantumInstance</span><span class="p">(</span><span class="n">Aer</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="s2">&quot;aer_simulator_statevector&quot;</span><span class="p">))</span>

<span class="c1"># construct QNN</span>
<span class="n">qnn</span> <span class="o">=</span> <span class="n">CircuitQNN</span><span class="p">(</span>
    <span class="n">qc</span><span class="p">,</span>
    <span class="n">input_params</span><span class="o">=</span><span class="n">feature_map</span><span class="o">.</span><span class="n">parameters</span><span class="p">,</span>
    <span class="n">weight_params</span><span class="o">=</span><span class="n">ansatz</span><span class="o">.</span><span class="n">parameters</span><span class="p">,</span>
    <span class="n">interpret</span><span class="o">=</span><span class="n">parity</span><span class="p">,</span>
    <span class="n">output_shape</span><span class="o">=</span><span class="n">output_shape</span><span class="p">,</span>
    <span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">quantum_instance</span><span class="o">=</span><span class="n">qi_sv</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
</section>
<section id="3.2-Configurar-el-cálculo-de-la-Dimensión-Efectiva">
<h3>3.2 Configurar el cálculo de la Dimensión Efectiva<a class="headerlink" href="#3.2-Configurar-el-cálculo-de-la-Dimensión-Efectiva" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Para calcular la dimensión efectiva de nuestra QNN usando la clase <code class="docutils literal notranslate"><span class="pre">EffectiveDimension</span></code>, necesitamos una serie de conjuntos de muestras y pesos de entrada, así como el número total de muestras de datos disponibles en un conjunto de datos. Las <code class="docutils literal notranslate"><span class="pre">input_samples</span></code> y <code class="docutils literal notranslate"><span class="pre">weight_samples</span></code> se establecen en el constructor de la clase, mientras que el número de muestras de datos se proporciona durante la llamada al cálculo de la dimensión efectiva, para poder probar y comparar cómo cambia esta medida con diferentes tamaños de conjuntos de datos.</p>
<p>Podemos definir el número de muestras de entrada y muestras de peso y la clase muestreará aleatoriamente un arreglo correspondiente a una distribución normal (para <code class="docutils literal notranslate"><span class="pre">input_samples</span></code>) o uniforme (para <code class="docutils literal notranslate"><span class="pre">weight_samples</span></code>). En lugar de pasar una cantidad de muestras, podemos pasar una matriz, muestreada manualmente.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[5]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># we can set the total number of input samples and weight samples for random selection</span>
<span class="n">num_input_samples</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">num_weight_samples</span> <span class="o">=</span> <span class="mi">10</span>

<span class="n">global_ed</span> <span class="o">=</span> <span class="n">EffectiveDimension</span><span class="p">(</span>
    <span class="n">qnn</span><span class="o">=</span><span class="n">qnn</span><span class="p">,</span> <span class="n">weight_samples</span><span class="o">=</span><span class="n">num_weight_samples</span><span class="p">,</span> <span class="n">input_samples</span><span class="o">=</span><span class="n">num_input_samples</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<p>Si queremos probar un conjunto específico de muestras de entrada y muestras de peso, podemos proporcionarlo directamente a la clase <code class="docutils literal notranslate"><span class="pre">EffectiveDimension</span></code> como se muestra en el siguiente fragmento de código:</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[6]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># we can also provide user-defined samples and parameters</span>
<span class="n">input_samples</span> <span class="o">=</span> <span class="n">algorithm_globals</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">qnn</span><span class="o">.</span><span class="n">num_inputs</span><span class="p">))</span>
<span class="n">weight_samples</span> <span class="o">=</span> <span class="n">algorithm_globals</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">qnn</span><span class="o">.</span><span class="n">num_weights</span><span class="p">))</span>

<span class="n">global_ed</span> <span class="o">=</span> <span class="n">EffectiveDimension</span><span class="p">(</span><span class="n">qnn</span><span class="o">=</span><span class="n">qnn</span><span class="p">,</span> <span class="n">weight_samples</span><span class="o">=</span><span class="n">weight_samples</span><span class="p">,</span> <span class="n">input_samples</span><span class="o">=</span><span class="n">input_samples</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>El algoritmo de dimensión efectiva también requiere un tamaño de conjunto de datos. En este ejemplo, definiremos un arreglo de tamaños para luego ver cómo esta entrada afecta el resultado.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[7]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># finally, we will define ranges to test different numbers of data, n</span>
<span class="n">n</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5000</span><span class="p">,</span> <span class="mi">8000</span><span class="p">,</span> <span class="mi">10000</span><span class="p">,</span> <span class="mi">40000</span><span class="p">,</span> <span class="mi">60000</span><span class="p">,</span> <span class="mi">100000</span><span class="p">,</span> <span class="mi">150000</span><span class="p">,</span> <span class="mi">200000</span><span class="p">,</span> <span class="mi">500000</span><span class="p">,</span> <span class="mi">1000000</span><span class="p">]</span>
</pre></div>
</div>
</div>
</section>
<section id="3.3-Calcular-la-Dimensión-Efectiva-Global">
<h3>3.3 Calcular la Dimensión Efectiva Global<a class="headerlink" href="#3.3-Calcular-la-Dimensión-Efectiva-Global" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Ahora calculemos la dimensión efectiva de nuestra red para el conjunto previamente definido de muestras de entrada, pesos y un tamaño de conjunto de datos de 5000.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[8]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">global_eff_dim_0</span> <span class="o">=</span> <span class="n">global_ed</span><span class="o">.</span><span class="n">get_effective_dimension</span><span class="p">(</span><span class="n">dataset_size</span><span class="o">=</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
</div>
<p>Los valores efectivos de dimensión oscilarán entre 0 y <code class="docutils literal notranslate"><span class="pre">d</span></code>, donde <code class="docutils literal notranslate"><span class="pre">d</span></code> representa la dimensión del modelo, y se obtiene prácticamente a partir del número de pesos de la QNN. Al dividir el resultado entre <code class="docutils literal notranslate"><span class="pre">d</span></code>, podemos obtener la dimensión efectiva normalizada, que se correlaciona directamente con la capacidad del modelo.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[9]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">d</span> <span class="o">=</span> <span class="n">qnn</span><span class="o">.</span><span class="n">num_weights</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Data size: </span><span class="si">{}</span><span class="s2">, global effective dimension: </span><span class="si">{:.4f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">global_eff_dim_0</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span>
    <span class="s2">&quot;Number of weights: </span><span class="si">{}</span><span class="s2">, normalized effective dimension: </span><span class="si">{:.4f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">global_eff_dim_0</span> <span class="o">/</span> <span class="n">d</span><span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Data size: 5000, global effective dimension: 4.6657
Number of weights: 6, normalized effective dimension: 0.7776
</pre></div></div>
</div>
<p>Al llamar a la clase <code class="docutils literal notranslate"><span class="pre">EffectiveDimension</span></code> con un arreglo de tamaños de entrada <code class="docutils literal notranslate"><span class="pre">n</span></code>, podemos monitorear cómo cambia la dimensión efectiva con el tamaño del conjunto de datos.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[10]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">global_eff_dim_1</span> <span class="o">=</span> <span class="n">global_ed</span><span class="o">.</span><span class="n">get_effective_dimension</span><span class="p">(</span><span class="n">dataset_size</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[11]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Effective dimension: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">global_eff_dim_1</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of weights: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Effective dimension: [4.66565096 4.7133723  4.73782922 4.89963559 4.94632272 5.00280009
 5.04530433 5.07408394 5.15786005 5.21349874]
Number of weights: 6
</pre></div></div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[12]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># plot the normalized effective dimension for the model</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">global_eff_dim_1</span><span class="p">)</span> <span class="o">/</span> <span class="n">d</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Number of data&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Normalized GLOBAL effective dimension&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/tutorials_10_effective_dimension_24_0.png" src="../_images/tutorials_10_effective_dimension_24_0.png" />
</div>
</div>
</section>
</section>
<section id="4.-Ejemplo-de-Dimensión-Efectiva-Local">
<h2>4. Ejemplo de Dimensión Efectiva Local<a class="headerlink" href="#4.-Ejemplo-de-Dimensión-Efectiva-Local" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Como se explicó en la introducción, el algoritmo de dimensión efectiva local solo usa <strong>un</strong> conjunto de pesos y se puede usar para monitorear cómo el entrenamiento afecta la expresividad de una red neuronal. La clase <code class="docutils literal notranslate"><span class="pre">LocalEffectiveDimension</span></code> impone esta restricción para garantizar que estos cálculos sean conceptualmente independientes, pero el resto de la implementación se comparte con <code class="docutils literal notranslate"><span class="pre">EffectiveDimension</span></code>.</p>
<p>Este ejemplo muestra cómo aprovechar la clase <code class="docutils literal notranslate"><span class="pre">LocalEffectiveDimension</span></code> para analizar el efecto del entrenamiento en la expresividad de la QNN.</p>
<section id="4.1-Definir-el-Conjunto-de-Datos-y-QNN">
<h3>4.1 Definir el Conjunto de Datos y QNN<a class="headerlink" href="#4.1-Definir-el-Conjunto-de-Datos-y-QNN" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Comenzamos creando un conjunto de datos de clasificación binaria 3D:</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[13]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">num_inputs</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">num_samples</span> <span class="o">=</span> <span class="mi">50</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">algorithm_globals</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">num_samples</span><span class="p">,</span> <span class="n">num_inputs</span><span class="p">))</span>

<span class="n">y01</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># in { 0,  1}</span>
<span class="n">y</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">y01</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># in {-1, +1}</span>
</pre></div>
</div>
</div>
<p>El siguiente paso es crear una QNN, una instancia de <code class="docutils literal notranslate"><span class="pre">TwoLayerQNN</span></code> en nuestro caso. Dado que solo pasamos el número de entradas, la red continuará con los valores predeterminados para el mapa de características y el ansatz.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[14]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">opflow_qnn</span> <span class="o">=</span> <span class="n">TwoLayerQNN</span><span class="p">(</span><span class="n">num_inputs</span><span class="p">,</span> <span class="n">quantum_instance</span><span class="o">=</span><span class="n">qi_sv</span><span class="p">)</span>
</pre></div>
</div>
</div>
</section>
<section id="4.2-Entrenar-QNN">
<h3>4.2 Entrenar QNN<a class="headerlink" href="#4.2-Entrenar-QNN" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Ahora podemos proceder a entrenar la QNN. El paso de entrenamiento puede tomar algún tiempo, sé paciente. Puedes pasar una devolución de llamada al clasificador para observar cómo se desarrolla el proceso de capacitación. Fijamos <code class="docutils literal notranslate"><span class="pre">initial_point</span></code> con fines de reproducibilidad, como de costumbre.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[15]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># callback function that draws a live plot when the .fit() method is called</span>
<span class="k">def</span> <span class="nf">callback_graph</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">obj_func_eval</span><span class="p">):</span>
    <span class="n">clear_output</span><span class="p">(</span><span class="n">wait</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">objective_func_vals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj_func_eval</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Objective function value against iteration&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Iteration&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Objective function value&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">objective_func_vals</span><span class="p">)),</span> <span class="n">objective_func_vals</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[16]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># construct classifier</span>
<span class="n">initial_point</span> <span class="o">=</span> <span class="n">algorithm_globals</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">opflow_qnn</span><span class="o">.</span><span class="n">num_weights</span><span class="p">)</span>

<span class="n">opflow_classifier</span> <span class="o">=</span> <span class="n">NeuralNetworkClassifier</span><span class="p">(</span>
    <span class="n">neural_network</span><span class="o">=</span><span class="n">opflow_qnn</span><span class="p">,</span>
    <span class="n">optimizer</span><span class="o">=</span><span class="n">COBYLA</span><span class="p">(</span><span class="n">maxiter</span><span class="o">=</span><span class="mi">150</span><span class="p">),</span>
    <span class="n">initial_point</span><span class="o">=</span><span class="n">initial_point</span><span class="p">,</span>
    <span class="n">callback</span><span class="o">=</span><span class="n">callback_graph</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[17]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># create empty array for callback to store evaluations of the objective function (callback)</span>
<span class="n">objective_func_vals</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s2">&quot;figure.figsize&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>

<span class="c1"># fit classifier to data</span>
<span class="n">opflow_classifier</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

<span class="c1"># return to default figsize</span>
<span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s2">&quot;figure.figsize&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/tutorials_10_effective_dimension_33_0.png" src="../_images/tutorials_10_effective_dimension_33_0.png" />
</div>
</div>
<p>El clasificador ahora puede diferenciar entre clases con una precisión de:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[18]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># score classifier</span>
<span class="n">opflow_classifier</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[18]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
0.68
</pre></div></div>
</div>
</section>
<section id="4.3-Calcular-la-Dimensión-Efectiva-Local-de-QNN-entrenadas">
<h3>4.3 Calcular la Dimensión Efectiva Local de QNN entrenadas<a class="headerlink" href="#4.3-Calcular-la-Dimensión-Efectiva-Local-de-QNN-entrenadas" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Ahora que hemos entrenado nuestra red, evaluemos la dimensión efectiva local en función de los pesos entrenados. Para ello accedemos a los pesos entrenados directamente desde el clasificador.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[19]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">trained_weights</span> <span class="o">=</span> <span class="n">opflow_classifier</span><span class="o">.</span><span class="n">_fit_result</span><span class="o">.</span><span class="n">x</span>

<span class="c1"># get Local Effective Dimension for set of trained weights</span>
<span class="n">local_ed_trained</span> <span class="o">=</span> <span class="n">LocalEffectiveDimension</span><span class="p">(</span>
    <span class="n">qnn</span><span class="o">=</span><span class="n">opflow_qnn</span><span class="p">,</span> <span class="n">weight_samples</span><span class="o">=</span><span class="n">trained_weights</span><span class="p">,</span> <span class="n">input_samples</span><span class="o">=</span><span class="n">X</span>
<span class="p">)</span>

<span class="n">local_eff_dim_trained</span> <span class="o">=</span> <span class="n">local_ed_trained</span><span class="o">.</span><span class="n">get_effective_dimension</span><span class="p">(</span><span class="n">dataset_size</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span>
    <span class="s2">&quot;normalized local effective dimensions for trained QNN: &quot;</span><span class="p">,</span>
    <span class="n">local_eff_dim_trained</span> <span class="o">/</span> <span class="n">opflow_qnn</span><span class="o">.</span><span class="n">num_weights</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
normalized local effective dimensions for trained QNN:  [0.79663244 0.80325759 0.80653351 0.82723511 0.83320702 0.84062917
 0.84641928 0.85045673 0.86276589 0.87134912]
</pre></div></div>
</div>
</section>
<section id="4.4-Calcular-la-Dimensión-Efectiva-Local-de-QNN-no-entrenadas">
<h3>4.4 Calcular la Dimensión Efectiva Local de QNN no entrenadas<a class="headerlink" href="#4.4-Calcular-la-Dimensión-Efectiva-Local-de-QNN-no-entrenadas" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Podemos comparar este resultado con la dimensión efectiva de la red no entrenada, usando el <code class="docutils literal notranslate"><span class="pre">initial_point</span></code> como nuestra muestra de peso:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[20]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># get Local Effective Dimension for set of untrained weights</span>
<span class="n">local_ed_untrained</span> <span class="o">=</span> <span class="n">LocalEffectiveDimension</span><span class="p">(</span>
    <span class="n">qnn</span><span class="o">=</span><span class="n">opflow_qnn</span><span class="p">,</span> <span class="n">weight_samples</span><span class="o">=</span><span class="n">initial_point</span><span class="p">,</span> <span class="n">input_samples</span><span class="o">=</span><span class="n">X</span>
<span class="p">)</span>

<span class="n">local_eff_dim_untrained</span> <span class="o">=</span> <span class="n">local_ed_untrained</span><span class="o">.</span><span class="n">get_effective_dimension</span><span class="p">(</span><span class="n">dataset_size</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span>
    <span class="s2">&quot;normalized local effective dimensions for untrained QNN: &quot;</span><span class="p">,</span>
    <span class="n">local_eff_dim_untrained</span> <span class="o">/</span> <span class="n">opflow_qnn</span><span class="o">.</span><span class="n">num_weights</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
normalized local effective dimensions for untrained QNN:  [0.80896667 0.81612261 0.81966781 0.84219603 0.84864578 0.85651291
 0.86249025 0.86656428 0.8785217  0.88651616]
</pre></div></div>
</div>
</section>
<section id="4.5-Graficar-y-analizar-resultados">
<h3>4.5 Graficar y analizar resultados<a class="headerlink" href="#4.5-Graficar-y-analizar-resultados" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Si graficamos los valores de las dimensiones efectivas antes y después del entrenamiento, podemos ver el siguiente resultado:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[21]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># plot the normalized effective dimension for the model</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">local_eff_dim_trained</span><span class="p">)</span> <span class="o">/</span> <span class="n">opflow_qnn</span><span class="o">.</span><span class="n">num_weights</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;trained weights&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">local_eff_dim_untrained</span><span class="p">)</span> <span class="o">/</span> <span class="n">opflow_qnn</span><span class="o">.</span><span class="n">num_weights</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;untrained weights&quot;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Number of data&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Normalized LOCAL effective dimension&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/tutorials_10_effective_dimension_41_0.png" src="../_images/tutorials_10_effective_dimension_41_0.png" />
</div>
</div>
<p>En general, deberíamos esperar que el valor de la dimensión efectiva local disminuya después del entrenamiento. Esto se puede entender mirando hacia atrás en el objetivo principal del machine learning, que es elegir un modelo que sea lo suficientemente expresivo como para ajustarse a sus datos, pero no demasiado expresivo como para que se ajuste demasiado y funcione mal en nuevas muestras de datos.</p>
<p>Ciertos optimizadores ayudan a regularizar el sobreajuste de un modelo mediante el aprendizaje de parámetros, y esta acción de aprendizaje reduce inherentemente la expresividad de un modelo, medida por la dimensión efectiva local. Siguiendo esta lógica, lo más probable es que un conjunto de parámetros inicializados aleatoriamente produzca una dimensión efectiva más alta que el conjunto final de pesos entrenados, porque ese modelo con esa parametrización particular está “usando más parámetros” innecesariamente para ajustar los datos. Después del entrenamiento (con la regularización implícita), un modelo entrenado no necesitará usar tantos parámetros y, por lo tanto, tendrá más “parámetros inactivos” y una dimensión efectiva menor.</p>
<p>Sin embargo, debemos tener en cuenta que esta es la intuición general, y puede haber casos en los que un conjunto de pesos seleccionados al azar proporcione una dimensión efectiva más baja que los pesos entrenados para un modelo específico.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[22]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">qiskit.tools.jupyter</span>

<span class="o">%</span><span class="k">qiskit_version_table</span>
<span class="o">%</span><span class="k">qiskit_copyright</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area rendered_html docutils container">
<h3>Version Information</h3><table><tr><th>Qiskit Software</th><th>Version</th></tr><tr><td><code>qiskit-terra</code></td><td>0.20.1</td></tr><tr><td><code>qiskit-aer</code></td><td>0.10.3</td></tr><tr><td><code>qiskit-ignis</code></td><td>0.7.0</td></tr><tr><td><code>qiskit-ibmq-provider</code></td><td>0.18.3</td></tr><tr><td><code>qiskit</code></td><td>0.34.2</td></tr><tr><td><code>qiskit-machine-learning</code></td><td>0.4.0</td></tr><tr><th>System information</th></tr><tr><td>Python version</td><td>3.10.0</td></tr><tr><td>Python compiler</td><td>Clang 12.0.0 </td></tr><tr><td>Python build</td><td>default, Nov 10 2021 11:24:47</td></tr><tr><td>OS</td><td>Darwin</td></tr><tr><td>CPUs</td><td>8</td></tr><tr><td>Memory (Gb)</td><td>64.0</td></tr><tr><td colspan='2'>Tue Apr 26 21:08:28 2022 CEST</td></tr></table></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area rendered_html docutils container">
<div style='width: 100%; background-color:#d5d9e0;padding-left: 10px; padding-bottom: 10px; padding-right: 10px; padding-top: 5px'><h3>This code is a part of Qiskit</h3><p>&copy; Copyright IBM 2017, 2022.</p><p>This code is licensed under the Apache License, Version 2.0. You may<br>obtain a copy of this license in the LICENSE.txt file in the root directory<br> of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.<p>Any modifications or derivative works of this code must retain this<br>copyright notice, and modified files need to carry a notice indicating<br>that they have been altered from the originals.</p></div></div>
</div>
</section>
</section>
</section>


             </article>
             
            </div>
            <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../release_notes.html" class="btn btn-neutral float-right" title="Release Notes" accesskey="n" rel="next">Next <img src="../_static/images/chevron-right-orange.svg" class="next-page"></a>
      
      
        <a href="09_saving_and_loading%20models.html" class="btn btn-neutral" title="Guardar, Cargar modelos de Machine Learning de Qiskit y Entrenamiento Continuo" accesskey="p" rel="prev"><img src="../_static/images/chevron-right-orange.svg" class="previous-page"> Previous</a>
      
    </div>
  

  

    <hr>

  

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, 2021, Qiskit Machine Learning Development Team.

    </p>
  </div>
    
      <div>
        Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
      </div>
     

</footer>

          </div>
        </div>

        <div class="pytorch-content-right" id="pytorch-content-right">
          <div class="pytorch-right-menu" id="pytorch-right-menu">
            <div class="pytorch-side-scroll" id="pytorch-side-scroll-right">
              <ul>
<li><a class="reference internal" href="#">Dimensión Efectiva de las Redes Neuronales de Qiskit</a><ul>
<li><a class="reference internal" href="#1.-Dimensión-Efectiva-Global-vs. Local">1. Dimensión Efectiva Global vs. Local</a></li>
<li><a class="reference internal" href="#2.-El-Algoritmo-de-Dimensión-Efectiva">2. El Algoritmo de Dimensión Efectiva</a></li>
<li><a class="reference internal" href="#3.-Ejemplo-Básico-(CircuitQNN)">3. Ejemplo Básico (CircuitQNN)</a><ul>
<li><a class="reference internal" href="#3.1-Definir-QNN">3.1 Definir QNN</a></li>
<li><a class="reference internal" href="#3.2-Configurar-el-cálculo-de-la-Dimensión-Efectiva">3.2 Configurar el cálculo de la Dimensión Efectiva</a></li>
<li><a class="reference internal" href="#3.3-Calcular-la-Dimensión-Efectiva-Global">3.3 Calcular la Dimensión Efectiva Global</a></li>
</ul>
</li>
<li><a class="reference internal" href="#4.-Ejemplo-de-Dimensión-Efectiva-Local">4. Ejemplo de Dimensión Efectiva Local</a><ul>
<li><a class="reference internal" href="#4.1-Definir-el-Conjunto-de-Datos-y-QNN">4.1 Definir el Conjunto de Datos y QNN</a></li>
<li><a class="reference internal" href="#4.2-Entrenar-QNN">4.2 Entrenar QNN</a></li>
<li><a class="reference internal" href="#4.3-Calcular-la-Dimensión-Efectiva-Local-de-QNN-entrenadas">4.3 Calcular la Dimensión Efectiva Local de QNN entrenadas</a></li>
<li><a class="reference internal" href="#4.4-Calcular-la-Dimensión-Efectiva-Local-de-QNN-no-entrenadas">4.4 Calcular la Dimensión Efectiva Local de QNN no entrenadas</a></li>
<li><a class="reference internal" href="#4.5-Graficar-y-analizar-resultados">4.5 Graficar y analizar resultados</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            </div>
          </div>
        </div>
      </section>
    </div>

  

     
       <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
         <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
         <script src="../_static/jquery.js"></script>
         <script src="../_static/underscore.js"></script>
         <script src="../_static/doctools.js"></script>
         <script src="../_static/thebelab-helper.js"></script>
         <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
         <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.20.1/dist/embed-amd.js"></script>
         <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
         <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
         <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
     

  

  <script type="text/javascript" src="../_static/js/vendor/popper.min.js"></script>
  <script type="text/javascript" src="../_static/js/vendor/bootstrap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/list.js/1.5.0/list.min.js"></script>
  <script type="text/javascript" src="../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 <script type="text/javascript">
    $(document).ready(function() {
        $(".toggle > *").hide();
        $(".toggle .header").show();
        $(".toggle .header").click(function() {
            $(this).parent().children().not(".header").toggle(400);
            $(this).parent().children(".header").toggleClass("open");
        })
    });
</script>


  <div>
    <br>
  </div>

  <!-- Begin Mobile Menu -->

  <div class="mobile-main-menu">
    <div class="container-fluid">
      <div class="container">
        <div class="mobile-main-menu-header-container">
          <a class="header-logo" href="https://qiskit.org/" aria-label="PyTorch"></a>
          <a class="main-menu-close-button" href="#" data-behavior="close-mobile-menu"></a>
        </div>
      </div>
    </div>

    <div class="mobile-main-menu-links-container">
      <div class="main-menu">
        <ul>
          <li>
            <a href="../getting_started.html">Getting Started</a>
          </li>
          <li>
            <a href="https://qiskit.org/documentation/machine-learning/tutorials/index.html" target="_blank">Tutorials</a>
          </li>
          <li>
            <a href="https://qiskit.org/documentation/partners/">Partners</a>
          </li>
          <br>
          <li class="resources-mobile-menu-title">
            Applications
          </li>
          <ul class="resources-mobile-menu-items">
            <li>
              <a href="https://qiskit.org/documentation/machine-learning/">Machine learning</a>
            </li>

            <li>
              <a href="https://qiskit.org/documentation/nature/">Nature</a>
            </li>

            <li>
              <a href="https://qiskit.org/documentation/finance/">Finance</a>
            </li>

            <li>
              <a href="https://qiskit.org/documentation/optimization/">Optimization</a>
            </li>
          </ul>
          <br>
          <li>
            <a href="https://qiskit.org/documentation/experiments/">Experiments</a>
          </li>
          <br>
          <li class="resources-mobile-menu-title">
            Resources
          </li>

          <ul class="resources-mobile-menu-items">
            <li>
              <a href="https://qiskit.slack.com">Slack support</a>
            </li>
          </ul>
          <br>
        </ul>
      </div>
    </div>
  </div>

  <!-- End Mobile Menu -->

  <script type="text/javascript" src="../_static/js/vendor/anchor.min.js"></script>

  <script type="text/javascript">
    $(document).ready(function() {
      mobileMenu.bind();
      mobileTOC.bind();
      pytorchAnchors.bind();
      sideMenus.bind();
      scrollToAnchor.bind();
      highlightNavigation.bind();
      mainMenuDropdown.bind();
      filterTags.bind();

      // Add class to links that have code blocks, since we cannot create links in code blocks
      $("article.pytorch-article a span.pre").each(function(e) {
        $(this).closest("a").addClass("has-code");
      });
    })
  </script>
</body>
</html>