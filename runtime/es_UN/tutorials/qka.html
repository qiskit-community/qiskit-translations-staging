


<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="es-UN" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="es-UN" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Alineación del Kernel Cuántico con Qiskit Runtime &mdash; documentación de Qiskit Runtime IBM Client - 0.6.1</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <!-- <link rel="stylesheet" href="../_static/pygments.css" type="text/css" /> -->
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/jupyter-sphinx.css" type="text/css" />
  <link rel="stylesheet" href="../_static/thebelab.css" type="text/css" />
  <link rel="stylesheet" href="../_static/tabs.css" type="text/css" />
  <link rel="stylesheet" href="../_static/style.css" type="text/css" />
  <link rel="stylesheet" href="../_static/gallery.css" type="text/css" />
    <link rel="index" title="Índice" href="../genindex.html" />
    <link rel="search" title="Búsqueda" href="../search.html" />
    <link rel="next" title="VQE" href="vqe.html" />
    <link rel="prev" title="Programa de Valor Esperado Personalizado para Qiskit Runtime" href="sample_expval_program/qiskit_runtime_expval_program.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<div class="container-fluid header-holder tutorials-header" id="header-holder">
  <div class="container">
    <div class="header-container">
      <a class="header-logo" href="https://qiskit.org/" aria-label="PyTorch"></a>

      <div class="main-menu">
        <ul>
          <li>
            <a href="../getting_started.html">Getting started</a>
          </li>

          <li>
            <a href="../tutorials.html">Tutorials</a>
          </li>

          <li>
            <a href="https://qiskit.org/documentation/partners/" target="_blank">Qiskit Providers</a>
          </li>

          <li>
            <div id="resourcesDropdownButton" data-toggle="resources-dropdown" class="resources-dropdown">
              <a class="resource-option with-down-orange-arrow">
                Applications
              </a>
              <div class="resources-dropdown-menu">
                <a class="nav-dropdown-item" href="https://qiskit.org/documentation/machine-learning/">
                  <span class="dropdown-title">Machine learning</span>
                  <p>QSVM, VQC (Variational Quantum Classifier), and QGAN (Quantum Generative
                    Adversarial Network) algorithms.</p>
                </a>
                <a class="nav-dropdown-item" href="https://qiskit.org/documentation/nature/">
                  <span class="dropdown-title">Nature</span>
                  <p>Quantum applications in chemistry, physics, and biology.</p>
                </a>
                <a class="nav-dropdown-item" href="https://qiskit.org/documentation/finance/">
                  <span class="dropdown-title">Finance</span>
                  <p>Uncertainty components for stock/securities problems, Ising translators for
                    portfolio optimizations and data providers to source real or random data.</p>
                </a>
                <a class="nav-dropdown-item" href="https://qiskit.org/documentation/optimization/">
                  <span class="dropdown-title">Optimization</span>
                  <p>High-level optimization problems that are ready to
                    run on simulators and real quantum devices</p>
                </a>
              </div>
          </li>

          <li>
            <div id="resourcesDropdownButton" data-toggle="resources-dropdown" class="resources-dropdown">
              <a class="resource-option with-down-orange-arrow">
                Resources
              </a>
              <div class="resources-dropdown-menu">
                <a class="doc-dropdown-option nav-dropdown-item" href="https://qiskit.slack.com">
                  <span class="dropdown-title">Slack support</span>
                  <p></p>
                </a>
                <a class="doc-dropdown-option nav-dropdown-item" href="https://qiskit.org/textbook">
                  <span class="dropdown-title">Qiskit Textbook</span>
                  <p></p>
                </a>
                <a class="doc-dropdown-option nav-dropdown-item" href="https://qiskit.org/events">
                  <span class="dropdown-title">Qiskit events</span>
                  <p></p>
                </a>
            </div>
          </li>
          <li>
            <a href="https://github.com/Qiskit/qiskit-ibm-runtime" target="_blank">Github</a>
          </li>
        </ul>
      </div>

      <a class="main-menu-open-button" href="#" data-behavior="open-mobile-menu"></a>
    </div>

  </div>
</div>


<body class="pytorch-body">

   

    

    <div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    <span class="rst-current-version-label">Spanish</span>
    <span class="rst-versions-dropdown-icon"></span>
  </span>
  <div class="rst-other-versions">
    
    <dl>
      <dt>Idiomas</dt>
      
        <dd><a class="version" href="/documentation/partners/qiskit_ibm_runtime/tutorials/qka.html">English</a></dd>
      
        <dd><a class="version" href="/documentation/partners/qiskit_ibm_runtime/locale/ja_JP/tutorials/qka.html">Japanese</a></dd>
      
        <dd><a class="version" href="/documentation/partners/qiskit_ibm_runtime/locale/es_UN/tutorials/qka.html">Spanish</a></dd>
      
    </dl>
    
  </div>
  <script>
    jQuery('.version').click((evt) => {
      const hash = window.location.hash
      const complete_url = evt.target.href + hash
      window.location = complete_url
      evt.preventDefault()
    })
  </script>
</div>

    <div class="table-of-contents-link-wrapper">
      <span>Table of Contents</span>
      <a href="#" class="toggle-table-of-contents" data-behavior="toggle-table-of-contents"></a>
    </div>

    <nav data-toggle="wy-nav-shift" class="pytorch-left-menu" id="pytorch-left-menu">
      <div class="pytorch-side-scroll">
        <div class="pytorch-menu pytorch-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          <div class="pytorch-left-menu-search">
            

            
              
              
            

            


  


<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search Docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

            
          </div>

          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../index.html">Descripción General</a></li>
<li class="toctree-l1"><a class="reference internal" href="../getting_started.html">Primeros Pasos</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../tutorials.html">Tutoriales</a></li>
<li class="toctree-l1"><a class="reference internal" href="../how_to.html">Cómo Hacerlo</a></li>
<li class="toctree-l1"><a class="reference internal" href="../apidocs/ibm-runtime.html">Referencia de la API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../faqs.html">Preguntas Frecuentes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../release_notes.html">Notas de la Versión</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/Qiskit/qiskit-ibm-runtime">GitHub</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <div class="pytorch-container">
      <div class="pytorch-page-level-bar" id="pytorch-page-level-bar">
        <div class="pytorch-breadcrumbs-wrapper">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="pytorch-breadcrumbs">
    
      <li>
        <a href="../index.html">
          
            Docs
          
        </a> &gt;
      </li>

        
          <li><a href="../tutorials.html">Tutoriales</a> &gt;</li>
        
      <li>Alineación del Kernel Cuántico con Qiskit Runtime</li>
    
    
      <li class="pytorch-breadcrumbs-aside">
        
            
            <a href="../_sources/tutorials/qka.ipynb" rel="nofollow"><img src="../_static/images/view-page-source-icon.svg"></a>
          
        
      </li>
    
  </ul>

  
</div>
        </div>

        <div class="pytorch-shortcuts-wrapper" id="pytorch-shortcuts-wrapper">
          Shortcuts
        </div>
      </div>

      <section data-toggle="wy-nav-shift" id="pytorch-content-wrap" class="pytorch-content-wrap">
        <div class="pytorch-content-left">
          
          <div class="rst-content style-external-links">
          
            <div role="main" class="main-content" itemscope="itemscope" itemtype="http://schema.org/Article">
             <article itemprop="articleBody" id="pytorch-article" class="pytorch-article">
              
  
<style>
/* CSS for nbsphinx extension */

/* remove conflicting styling from Sphinx themes */
div.nbinput.container div.prompt *,
div.nboutput.container div.prompt *,
div.nbinput.container div.input_area pre,
div.nboutput.container div.output_area pre,
div.nbinput.container div.input_area .highlight,
div.nboutput.container div.output_area .highlight {
    border: none;
    padding: 0;
    margin: 0;
    box-shadow: none;
}

div.nbinput.container > div[class*=highlight],
div.nboutput.container > div[class*=highlight] {
    margin: 0;
}

div.nbinput.container div.prompt *,
div.nboutput.container div.prompt * {
    background: none;
}

div.nboutput.container div.output_area .highlight,
div.nboutput.container div.output_area pre {
    background: unset;
}

div.nboutput.container div.output_area div.highlight {
    color: unset;  /* override Pygments text color */
}

/* avoid gaps between output lines */
div.nboutput.container div[class*=highlight] pre {
    line-height: normal;
}

/* input/output containers */
div.nbinput.container,
div.nboutput.container {
    display: -webkit-flex;
    display: flex;
    align-items: flex-start;
    margin: 0;
    width: 100%;
}
@media (max-width: 540px) {
    div.nbinput.container,
    div.nboutput.container {
        flex-direction: column;
    }
}

/* input container */
div.nbinput.container {
    padding-top: 5px;
}

/* last container */
div.nblast.container {
    padding-bottom: 5px;
}

/* input prompt */
div.nbinput.container div.prompt pre {
    color: #307FC1;
}

/* output prompt */
div.nboutput.container div.prompt pre {
    color: #BF5B3D;
}

/* all prompts */
div.nbinput.container div.prompt,
div.nboutput.container div.prompt {
    width: 4.5ex;
    padding-top: 5px;
    position: relative;
    user-select: none;
}

div.nbinput.container div.prompt > div,
div.nboutput.container div.prompt > div {
    position: absolute;
    right: 0;
    margin-right: 0.3ex;
}

@media (max-width: 540px) {
    div.nbinput.container div.prompt,
    div.nboutput.container div.prompt {
        width: unset;
        text-align: left;
        padding: 0.4em;
    }
    div.nboutput.container div.prompt.empty {
        padding: 0;
    }

    div.nbinput.container div.prompt > div,
    div.nboutput.container div.prompt > div {
        position: unset;
    }
}

/* disable scrollbars on prompts */
div.nbinput.container div.prompt pre,
div.nboutput.container div.prompt pre {
    overflow: hidden;
}

/* input/output area */
div.nbinput.container div.input_area,
div.nboutput.container div.output_area {
    -webkit-flex: 1;
    flex: 1;
    overflow: auto;
}
@media (max-width: 540px) {
    div.nbinput.container div.input_area,
    div.nboutput.container div.output_area {
        width: 100%;
    }
}

/* input area */
div.nbinput.container div.input_area {
    border: 1px solid #e0e0e0;
    border-radius: 2px;
    /*background: #f5f5f5;*/
}

/* override MathJax center alignment in output cells */
div.nboutput.container div[class*=MathJax] {
    text-align: left !important;
}

/* override sphinx.ext.imgmath center alignment in output cells */
div.nboutput.container div.math p {
    text-align: left;
}

/* standard error */
div.nboutput.container div.output_area.stderr {
    background: #fdd;
}

/* ANSI colors */
.ansi-black-fg { color: #3E424D; }
.ansi-black-bg { background-color: #3E424D; }
.ansi-black-intense-fg { color: #282C36; }
.ansi-black-intense-bg { background-color: #282C36; }
.ansi-red-fg { color: #E75C58; }
.ansi-red-bg { background-color: #E75C58; }
.ansi-red-intense-fg { color: #B22B31; }
.ansi-red-intense-bg { background-color: #B22B31; }
.ansi-green-fg { color: #00A250; }
.ansi-green-bg { background-color: #00A250; }
.ansi-green-intense-fg { color: #007427; }
.ansi-green-intense-bg { background-color: #007427; }
.ansi-yellow-fg { color: #DDB62B; }
.ansi-yellow-bg { background-color: #DDB62B; }
.ansi-yellow-intense-fg { color: #B27D12; }
.ansi-yellow-intense-bg { background-color: #B27D12; }
.ansi-blue-fg { color: #208FFB; }
.ansi-blue-bg { background-color: #208FFB; }
.ansi-blue-intense-fg { color: #0065CA; }
.ansi-blue-intense-bg { background-color: #0065CA; }
.ansi-magenta-fg { color: #D160C4; }
.ansi-magenta-bg { background-color: #D160C4; }
.ansi-magenta-intense-fg { color: #A03196; }
.ansi-magenta-intense-bg { background-color: #A03196; }
.ansi-cyan-fg { color: #60C6C8; }
.ansi-cyan-bg { background-color: #60C6C8; }
.ansi-cyan-intense-fg { color: #258F8F; }
.ansi-cyan-intense-bg { background-color: #258F8F; }
.ansi-white-fg { color: #C5C1B4; }
.ansi-white-bg { background-color: #C5C1B4; }
.ansi-white-intense-fg { color: #A1A6B2; }
.ansi-white-intense-bg { background-color: #A1A6B2; }

.ansi-default-inverse-fg { color: #FFFFFF; }
.ansi-default-inverse-bg { background-color: #000000; }

.ansi-bold { font-weight: bold; }
.ansi-underline { text-decoration: underline; }


div.nbinput.container div.input_area div[class*=highlight] > pre,
div.nboutput.container div.output_area div[class*=highlight] > pre,
div.nboutput.container div.output_area div[class*=highlight].math,
div.nboutput.container div.output_area.rendered_html,
div.nboutput.container div.output_area > div.output_javascript,
div.nboutput.container div.output_area:not(.rendered_html) > img{
    padding: 5px;
    margin: 0;
}

/* fix copybtn overflow problem in chromium (needed for 'sphinx_copybutton') */
div.nbinput.container div.input_area > div[class^='highlight'],
div.nboutput.container div.output_area > div[class^='highlight']{
    overflow-y: hidden;
}

/* hide copybtn icon on prompts (needed for 'sphinx_copybutton') */
.prompt .copybtn {
    display: none;
}

/* Some additional styling taken form the Jupyter notebook CSS */
.jp-RenderedHTMLCommon table,
div.rendered_html table {
  border: none;
  border-collapse: collapse;
  border-spacing: 0;
  color: black;
  font-size: 12px;
  table-layout: fixed;
}
.jp-RenderedHTMLCommon thead,
div.rendered_html thead {
  border-bottom: 1px solid black;
  vertical-align: bottom;
}
.jp-RenderedHTMLCommon tr,
.jp-RenderedHTMLCommon th,
.jp-RenderedHTMLCommon td,
div.rendered_html tr,
div.rendered_html th,
div.rendered_html td {
  text-align: right;
  vertical-align: middle;
  padding: 0.5em 0.5em;
  line-height: normal;
  white-space: normal;
  max-width: none;
  border: none;
}
.jp-RenderedHTMLCommon th,
div.rendered_html th {
  font-weight: bold;
}
.jp-RenderedHTMLCommon tbody tr:nth-child(odd),
div.rendered_html tbody tr:nth-child(odd) {
  background: #f5f5f5;
}
.jp-RenderedHTMLCommon tbody tr:hover,
div.rendered_html tbody tr:hover {
  background: rgba(66, 165, 245, 0.2);
}
</style>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Esta página fue generada a partir de <a class="reference external" href="https://github.com/Qiskit/qiskit-ibm-runtime/blob/stable/0.6/docs/tutorials/qka.ipynb">docs/tutorials/qka.ipynb</a>.</p>
</div>
<section id="Alineación-del-Kernel-Cuántico-con-Qiskit-Runtime">
<h1>Alineación del Kernel Cuántico con Qiskit Runtime<a class="headerlink" href="#Alineación-del-Kernel-Cuántico-con-Qiskit-Runtime" title="Permalink to this heading">¶</a></h1>
<p><strong>Clasificación con Máquinas de Vectores de Soporte</strong>Los problemas de clasificación están muy extendidos en las aplicaciones de machine learning. Los ejemplos incluyen riesgo de tarjeta de crédito, reconocimiento de escritura a mano y diagnóstico médico. Un enfoque para abordar los problemas de clasificación es la máquina de vectores de soporte (support vector machine, SVM) [1,2]. Este algoritmo de aprendizaje supervisado utiliza muestras de datos etiquetados para entrenar un modelo que puede predecir a qué clase pertenece una muestra de prueba. Lo hace encontrando un hiperplano de separación que maximiza el margen entre las clases de datos. A menudo, los datos no se pueden separar linealmente en el espacio original. En estos casos, el truco del kernel se usa para codificar implícitamente una transformación de los datos en un espacio de características de mayor dimensión, a través del producto interno entre pares de puntos de datos, donde los datos pueden volverse separables.</p>
<p><strong>Kernels Cuánticos</strong>Las computadoras cuánticas se pueden usar para codificar datos clásicos en un espacio de funciones mejoradas cuánticamente. En 2019, IBM introdujo un algoritmo llamado estimador de kernel cuántico (quantum kernel estimator, QKE) para calcular kernels cuánticos [3]. Este algoritmo utiliza circuitos cuánticos con datos proporcionados de forma clásica y ofrece una forma eficiente de evaluar productos internos entre datos en un espacio de características cuánticas. Para dos muestras de datos <span class="math notranslate nohighlight">\(\theta\)</span> y <span class="math notranslate nohighlight">\(\theta'\)</span>, la matriz del kernel está dada como</p>
<div class="math notranslate nohighlight">
\[K(\theta, \theta') = \lvert\langle 0^n \rvert U^\dagger(\theta) U(\theta') \lvert 0^n \rangle \rvert^2,\]</div>
<p>donde <span class="math notranslate nohighlight">\(U(\theta)\)</span> prepara el estado de la característica cuántica. Los kernels cuánticos utilizados en un framework de clasificación heredan el programa de optimización convexa de SVM y evitan las limitaciones comunes de los clasificadores cuánticos variacionales. Una observación clave de este artículo fue que una condición necesaria para una ventaja computacional requiere circuitos cuánticos para el kernel que son difíciles de simular de forma clásica. Más recientemente, IBM demostró que los kernels cuánticos pueden ofrecer aceleraciones superpolinómicas sobre cualquier aprendiz clásico en un problema de aprendizaje basado en la dificultad del problema del logaritmo discreto [4]. Esto significa que los kernels cuánticos algún día pueden ofrecer una ventaja cuántica en los problemas adecuados.</p>
<p><strong>Kernels Cuánticos que Explotan la Estructura de los Datos</strong>Un enfoque importante en la búsqueda de una ventaja cuántica práctica en el machine learning es identificar los kernels cuánticos para problemas de aprendizaje que tienen una estructura subyacente en los datos. Hemos dado un paso en esta dirección en nuestro artículo reciente [5], donde presentamos una amplia clase de kernels cuánticos que explotan la estructura de grupo en los datos. Los ejemplos de problemas de aprendizaje para datos con estructura de grupo podrían incluir el aprendizaje de permutaciones o la clasificación de traducciones. Llamamos a esta nueva clase de núcleos <em>kernels cuánticos covariantes</em> ya que están relacionados con mediciones cuánticas covariantes. El mapa de características cuánticas está definido por una representación unitaria <span class="math notranslate nohighlight">\(D(\theta)\)</span> de un grupo <span class="math notranslate nohighlight">\(G\)</span> para algún elemento <span class="math notranslate nohighlight">\(\theta \in G\)</span>, y un estado de referencia fiducial <span class="math notranslate nohighlight">\(\lvert\psi\rangle = V\lvert0^n\rangle\)</span> preparado por un circuito unitario <span class="math notranslate nohighlight">\(V\)</span>. La matriz del kernel está dada como</p>
<div class="math notranslate nohighlight">
\[K(\theta, \theta') = \vert\langle 0^n \rvert V^\dagger D^\dagger(\theta) D(\theta') V \lvert 0^n \rangle \rvert^2. \qquad (1)\]</div>
<p>En general, la elección del estado fiducial no se conoce <em>a priori</em> y puede afectar significativamente el rendimiento del clasificador. Aquí, usamos un método llamado alineación del kernel cuántico (quantum kernel alignment, QKA) para encontrar un buen estado fiducial para un grupo determinado.</p>
<p><strong>Alineación de Kernels Cuánticos en un Conjunto de Datos</strong>En la práctica, las SVMs requieren una elección de la función del kernel. A veces, las simetrías en los datos pueden informar esta selección, otras veces se elige de manera ad hoc. La alineación del kernel es un enfoque para aprender un kernel en un conjunto de datos determinado al adaptarlo iterativamente para que tenga una gran similitud con un kernel objetivo informado a partir de la distribución de datos subyacente [6]. Como resultado, la SVM con un kernel alineado probablemente generalizará mejor los datos nuevos que con un kernel no alineado. Usando este concepto, presentamos en [5] un algoritmo para la alineación del kernel cuántico, que proporciona una forma de aprender un kernel cuántico de una familia de kernels. Específicamente, el algoritmo optimiza los parámetros en un circuito cuántico para maximizar la alineación de un kernel mientras converge al margen máximo de la SVM. En el contexto de los kernels cuánticos covariantes, extendemos la ecuación <span class="math notranslate nohighlight">\((1)\)</span> a</p>
<div class="math notranslate nohighlight">
\[K_\lambda(\theta,\theta') = \lvert\langle 0^n \rvert V^\dagger_\lambda D^\dagger(\theta) D(\theta') V_\lambda \lvert 0^n \rangle \rvert^2, \qquad (2)\]</div>
<p>y usamos QKA para aprender un buen estado fiducial parametrizado por <span class="math notranslate nohighlight">\(\lambda\)</span> para un grupo determinado.</p>
<p><strong>Kernels Cuánticos Covariantes en un Problema de Aprendizaje Específico</strong>Probemos QKA en un problema de aprendizaje. A continuación, consideraremos un problema de clasificación binaria que llamamos <em>etiquetado de clases laterales con error</em> [5]. En este problema, usaremos un grupo y un subgrupo para formar dos clases laterales, que representarán nuestras clases de datos. Tomamos el grupo <span class="math notranslate nohighlight">\(G = SU(2)^{\otimes n}\)</span> para <span class="math notranslate nohighlight">\(n\)</span> qubits, que es el grupo unitario especial de <span class="math notranslate nohighlight">\(2\times2\)</span> matrices y tiene una amplia aplicabilidad en la naturaleza, por ejemplo, el Modelo Estándar de física de partículas y en muchos sistemas de materia condensada. Tomamos el subgrupo estabilizador de grafos <span class="math notranslate nohighlight">\(S_{\mathrm{graph}} \in G\)</span> con <span class="math notranslate nohighlight">\(S_{\mathrm{graph}} = \langle \{ X_i \otimes_{k:(k,i) \in \mathcal{E}} Z_k \}_{i \in \mathcal{V}} \rangle\)</span> para un grafo <span class="math notranslate nohighlight">\((\mathcal{E},\mathcal{V})\)</span> con aristas <span class="math notranslate nohighlight">\(\mathcal{E}\)</span> y vértices <span class="math notranslate nohighlight">\(\mathcal{V}\)</span>. Ten en cuenta que los estabilizadores fijan un estado estabilizador tal que <span class="math notranslate nohighlight">\(D_s \lvert \psi\rangle = \lvert \psi\rangle\)</span>. Esta observación será útil un poco más adelante.</p>
<p>Para generar el conjunto de datos, escribimos las rotaciones del grupo como <span class="math notranslate nohighlight">\(D(\theta_1, \theta_2, 0)=\exp(i \theta_1 X) \exp(i \theta_2 Z) \in SU(2)\)</span>, de modo que cada qubit esté parametrizado por los dos primeros ángulos de Euler (el tercero lo ponemos en cero). Luego, dibujamos aleatoriamente dos conjuntos de ángulos <span class="math notranslate nohighlight">\(\mathbf{\theta}_\pm \in [-\pi/4, \pi/4]^{2n}\)</span> para el problema de <span class="math notranslate nohighlight">\(n\)</span> qubits A partir de estos dos conjuntos, construimos un problema de clasificación binaria formando dos clases laterales izquierdas (que representan las dos clases) con esos ángulos, <span class="math notranslate nohighlight">\(C_\pm = D(\mathbf{\theta}_\pm) S_{\mathrm{graph}}\)</span> donde <span class="math notranslate nohighlight">\(D(\mathbf{\theta}_\pm) = \otimes_{k=1}^n D(\theta_\pm^{2k-1}, \theta_\pm^{2k}, 0)\)</span>. Ten en cuenta que los elementos de las clases laterales se pueden escribir nuevamente en términos de los ángulos de Euler. Construimos conjuntos de entrenamiento y prueba dibujando elementos al azar de <span class="math notranslate nohighlight">\(C_\pm\)</span> de modo que el conjunto de datos tenga muestras <span class="math notranslate nohighlight">\(i=1,...,m\)</span> que contengan los dos primeros ángulos de Euler para cada qubit <span class="math notranslate nohighlight">\(\mathbf{\theta}_{y_i} = (\theta_{y_i}^{1}, \theta_{y_i}^{2}, \theta_{y_i}^{3}, \theta_{y_i}^{4}, ..., \theta_{y_i}^{2n-1}, \theta_{y_i}^{2n})\)</span> y etiquetas <span class="math notranslate nohighlight">\(y_i \in \{-1,1\}\)</span> que indican a qué clase lateral pertenece una muestra.</p>
<p>A continuación, seleccionamos un estado fiducial. Un candidato natural es el estado estabilizador que encontramos arriba. ¿Por qué? Debido a que este es un estado invariable de subgrupo, <span class="math notranslate nohighlight">\(D_s\lvert\psi\rangle = \lvert\psi\rangle\)</span>, lo que hace que los datos de una clase lateral determinada se mapeen a un estado único: <span class="math notranslate nohighlight">\(D(\mathbf{\theta}_\pm)D_s \lvert\psi\rangle = D(\mathbf{\theta}_\pm) \lvert\psi\rangle\)</span>. Esto significa que el clasificador solo necesita distinguir los <em>dos</em> estados <span class="math notranslate nohighlight">\(D(\mathbf{\theta}_\pm) \lvert\psi\rangle \langle \psi\rvert D^\dagger(\mathbf{\theta}_\pm)\)</span> para cada elemento de la clase lateral. En este tutorial, agregaremos un pequeño error Gaussiano con varianza <span class="math notranslate nohighlight">\(0.01\)</span> a los ángulos de Euler del conjunto de datos. Este ruido perturbará estos dos estados, pero si la varianza es lo suficientemente pequeña, esperamos que los estados se clasifiquen correctamente. Consideremos una versión parametrizada del estado estabilizador, asociado con el grafo de acoplamiento <span class="math notranslate nohighlight">\((\mathcal{E},\mathcal{V})\)</span> dado por la conectividad del dispositivo, como nuestro estado fiducial y luego usemos la alineación del kernel para encontrar sus parámetros óptimos. Específicamente, reemplazaremos las capas iniciales de Hadamards en el estado del grafo con rotaciones <span class="math notranslate nohighlight">\(y\)</span> por un ángulo <span class="math notranslate nohighlight">\(\lambda\)</span>,</p>
<div class="math notranslate nohighlight">
\[\lvert \psi_\lambda\rangle = V_\lambda \lvert 0^n\rangle = \prod_{(k,t) \in \mathcal{E}} CZ_{k,t} \prod_{k \in \mathcal{V}} \exp\left(i \frac{\lambda}{2} Y_k\right)\lvert 0^n\rangle,\]</div>
<p>donde <span class="math notranslate nohighlight">\(CZ=\mathrm{diag}(1,1,1,-1)\)</span>. Luego, dadas dos muestras de nuestro conjunto de datos, <span class="math notranslate nohighlight">\(\mathbf{\theta}\)</span> y <span class="math notranslate nohighlight">\(\mathbf{\theta}'\)</span>, la matriz del kernel se evalúa como en la ecuación <span class="math notranslate nohighlight">\((2)\)</span>. Si inicializamos el kernel con <span class="math notranslate nohighlight">\(\lambda \approx 0\)</span>, esperamos que el algoritmo de alineación del kernel cuántico converja hacia <span class="math notranslate nohighlight">\(\lambda = \pi/2\)</span> óptima y el clasificador produzca una precisión de prueba del 100%.</p>
<p>Definamos dos instancias de problemas específicos para probar estas ideas. Usaremos el dispositivo cuántico <code class="docutils literal notranslate"><span class="pre">ibmq_montreal</span></code>, con el mapa de acoplamiento que se muestra a continuación:</p>
<p><img alt="21a9c788313d46c58ba30d4426073340" class="no-scaled-link" src="../_images/chip.png" style="width: 500px;" /></p>
<p>Elegiremos dos subgrafos diferentes, uno para 7 qubits y otro para 10, para definir nuestras instancias de problemas. Usando estos subgrafos, generaremos los conjuntos de datos correspondientes como se describió arriba y luego alinearemos el kernel cuántico con QKA para aprender un buen estado fiducial.</p>
<p><img alt="7c0dccc907144c17b7262a1d0c8fe75b" class="no-scaled-link" src="../_images/subgraphs.png" style="width: 550px;" /></p>
<p><strong>Algoritmos de Aceleración con Qiskit Runtime</strong>QKA es un algoritmo iterativo cuántico-clásico, en el que se utiliza hardware cuántico para ejecutar circuitos cuánticos parametrizados para evaluar las matrices del kernel cuántico con QKE, mientras que un optimizador clásico ajusta los parámetros de esos circuitos para maximizar la alineación. Los algoritmos iterativos de este tipo pueden ser lentos debido a la latencia entre los cálculos cuánticos y clásicos. Qiskit Runtime es una nueva arquitectura que puede acelerar los algoritmos iterativos como QKA al ubicar los cálculos clásicos junto con las ejecuciones de hardware cuántico. En este tutorial, usaremos QKA con Qiskit Runtime para aprender un buen kernel cuántico para el problema de <em>etiquetado de clases laterales con error</em> definido anteriormente.</p>
<p><strong>References</strong> [1] B. E. Boser, I. M. Guyon, and V. N. Vapnik, Proceedings of the Fifth Annual Workshop on Computational Learning Theory, COLT ’92 (Association for Computing Machinery, New York, NY, USA, 1992) pp. 144-152 <a class="reference external" href="https://doi.org/10.1145/130385.130401">enlace</a> [2] V. Vapnik, The Nature of Statistical Learning Theory, Information Science and Statistics (Springer New York, 2013) <a class="reference external" href="https://books.google.com/books?id=EqgACAAAQBAJ">enlace</a> [3] V. Havlíček, A. D. Córcoles, K. Temme, A. W. Harrow, A. Kandala, J. M. Chow, and J. M. Gambetta, Nature 567, 209-212 (2019) <a class="reference external" href="https://doi.org/10.1038/s41586-019-0980-2">enlace</a> [4] Y. Liu, S. Arunachalam, and K. Temme, arXiv:2010.02174 (2020) <a class="reference external" href="https://arxiv.org/abs/2010.02174">enlace</a> [5] J. R. Glick, T. P. Gujarati, A. D. Córcoles, Y. Kim, A. Kandala, J. M. Gambetta, K. Temme, arXiv:2105.03406 (2021) <a class="reference external" href="https://arxiv.org/abs/2105.03406">enlace</a> [6] N. Cristianini, J. Shawe-taylor, A. Elisseeff, and J. Kandola, Advances in Neural Information Processing Systems 14 (2001) <a class="reference external" href="https://proceedings.neurips.cc/paper/2001/file/1f71e393b3809197ed66df836fe833e5-Paper.pdf">enlace</a></p>
</section>
<section id="Carga-tu-cuenta-y-obtén-el-backend-cuántico">
<h1>Carga tu cuenta y obtén el backend cuántico<a class="headerlink" href="#Carga-tu-cuenta-y-obtén-el-backend-cuántico" title="Permalink to this heading">¶</a></h1>
<p>Usaremos el dispositivo de 27 qubits <code class="docutils literal notranslate"><span class="pre">ibmq_montreal</span></code> para este tutorial en Qiskit Runtime en IBM Quantum.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[1]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span>

<span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;..&quot;</span><span class="p">)</span>  <span class="c1"># Add program_source directory to the path</span>

<span class="kn">from</span> <span class="nn">qiskit_ibm_runtime</span> <span class="kn">import</span> <span class="n">QiskitRuntimeService</span>

<span class="n">service</span> <span class="o">=</span> <span class="n">QiskitRuntimeService</span><span class="p">(</span><span class="n">channel</span><span class="o">=</span><span class="s2">&quot;ibm_quantum&quot;</span><span class="p">)</span>
<span class="n">backend</span> <span class="o">=</span> <span class="n">service</span><span class="o">.</span><span class="n">backend</span><span class="p">(</span><span class="s2">&quot;ibmq_montreal&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</section>
<section id="Invocar-el-programa-de-Alineación-de-Kernel-Cuántico">
<h1>Invocar el programa de Alineación de Kernel Cuántico<a class="headerlink" href="#Invocar-el-programa-de-Alineación-de-Kernel-Cuántico" title="Permalink to this heading">¶</a></h1>
<p>Antes de ejecutar el programa runtime para QKA, debemos preparar el conjunto de datos y configurar los parámetros de entrada para el algoritmo.</p>
<section id="1.-Preparar-el-conjunto-de-datos">
<h2>1. Preparar el conjunto de datos<a class="headerlink" href="#1.-Preparar-el-conjunto-de-datos" title="Permalink to this heading">¶</a></h2>
<p>Primero, cargamos el conjunto de datos desde el archivo <code class="docutils literal notranslate"><span class="pre">csv</span></code> y luego extraemos las muestras de entrenamiento y prueba etiquetadas. Aquí, veremos el problema de 7 qubits, que se muestra arriba en la subfigura a). También está disponible un segundo conjunto de datos para el problema de 10 qubits en b).</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[2]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

<span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span>
    <span class="s2">&quot;./aux_file/dataset_graph7.csv&quot;</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;,&quot;</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span>  <span class="c1"># alterative problem: dataset_graph10.csv</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">values</span>
</pre></div>
</div>
</div>
<p>Echemos un vistazo a los datos para ver cómo están formateados. Cada fila del conjunto de datos contiene una lista de ángulos de Euler, seguida de la etiqueta de clase <span class="math notranslate nohighlight">\(\pm1\)</span> en la última columna. Para un problema de <span class="math notranslate nohighlight">\(n\)</span> qubits, hay <span class="math notranslate nohighlight">\(2n\)</span> características correspondientes a los dos primeros ángulos de Euler para cada qubit (recuerda la discusión anterior). Las filas alternan entre etiquetas de clase.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[3]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
         0         1         2         3         4         5         6   \
0 -0.193574  0.113979 -0.005927  0.300957 -0.358603 -0.087866 -0.156226
1 -0.100006  0.002431  0.244218  0.126870 -0.063891 -0.085588  0.072490
2 -1.774448 -0.047642 -0.025880  0.252708 -0.350689 -1.604509 -0.114874
3 -0.211585 -0.043782 -1.560226  0.018510 -0.051867 -0.128508  0.218609

         7         8         9         10        11        12        13   14
0  0.342442 -0.016003  0.143113  0.256422 -0.164125 -0.136743  0.014674  1.0
1  0.042986 -0.052714  0.019754 -0.159314 -0.409991 -0.199615  0.053845 -1.0
2  0.347631  0.059501 -0.168956  0.351014 -0.128586  0.098897 -0.047799  1.0
3 -0.075632 -0.183656 -1.715292 -0.105361 -0.300758 -0.566431  0.046542 -1.0
</pre></div></div>
</div>
<p>Ahora, construyamos explícitamente las muestras de entrenamiento y prueba (denotadas con <code class="docutils literal notranslate"><span class="pre">x</span></code>) y sus etiquetas (denotadas con <code class="docutils literal notranslate"><span class="pre">y</span></code>).</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[4]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="c1"># choose number of training and test samples per class:</span>
<span class="n">num_train</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">num_test</span> <span class="o">=</span> <span class="mi">10</span>

<span class="c1"># extract training and test sets and sort them by class label</span>
<span class="n">train</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">num_train</span><span class="p">,</span> <span class="p">:]</span>
<span class="n">test</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">num_train</span> <span class="p">:</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">num_train</span> <span class="o">+</span> <span class="n">num_test</span><span class="p">),</span> <span class="p">:]</span>

<span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">train</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="n">x_train</span> <span class="o">=</span> <span class="n">train</span><span class="p">[</span><span class="n">ind</span><span class="p">][:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="n">y_train</span> <span class="o">=</span> <span class="n">train</span><span class="p">[</span><span class="n">ind</span><span class="p">][:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>

<span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">test</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="n">x_test</span> <span class="o">=</span> <span class="n">test</span><span class="p">[</span><span class="n">ind</span><span class="p">][:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="n">y_test</span> <span class="o">=</span> <span class="n">test</span><span class="p">[</span><span class="n">ind</span><span class="p">][:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
</div>
</section>
<section id="2.-Configurar-el-algoritmo-QKA">
<h2>2. Configurar el algoritmo QKA<a class="headerlink" href="#2.-Configurar-el-algoritmo-QKA" title="Permalink to this heading">¶</a></h2>
<p>La primera tarea es configurar el mapa de características y su mapa entrelazador, que especifica la disposición de las compuertas <span class="math notranslate nohighlight">\(CZ\)</span> en el estado fiducial. Elegiremos esto para que coincida con la conectividad del subgrafo del problema, que se muestra arriba. También inicializamos el parámetro del estado fiducial <span class="math notranslate nohighlight">\(\lambda\)</span> con <code class="docutils literal notranslate"><span class="pre">initial_point</span></code>.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[5]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">program_source.qka</span> <span class="kn">import</span> <span class="n">FeatureMap</span>

<span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">data</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># feature dimension is twice the qubit number</span>

<span class="n">em</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>
<span class="p">]</span>  <span class="c1"># we&#39;ll match this to the 7-qubit graph</span>
<span class="c1"># em = [[0,1],[2,3],[4,5],[6,7],[8,9],[1,2],[3,4],[5,6],[7,8]]  # we&#39;ll match this to the 10-qubit graph</span>

<span class="n">fm</span> <span class="o">=</span> <span class="n">FeatureMap</span><span class="p">(</span><span class="n">feature_dimension</span><span class="o">=</span><span class="n">d</span><span class="p">,</span> <span class="n">entangler_map</span><span class="o">=</span><span class="n">em</span><span class="p">)</span>  <span class="c1"># define the feature map</span>
<span class="n">initial_point</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">]</span>  <span class="c1"># set the initial parameter for the feature map</span>
</pre></div>
</div>
</div>
<p>Imprimamos el circuito para el mapa de características (el circuito para el kernel será un mapa de características para una muestra de datos compuesta por un mapa de características inversas para una segunda muestra). La primera parte del mapa de características es el estado fiducial, que se prepara con una capa de rotaciones <span class="math notranslate nohighlight">\(y\)</span> seguidas de <span class="math notranslate nohighlight">\(CZ\)</span>s. Luego, las dos últimas capas de rotaciones <span class="math notranslate nohighlight">\(z\)</span> y <span class="math notranslate nohighlight">\(x\)</span> en el circuito denotan la representación del grupo <span class="math notranslate nohighlight">\(D(\theta)\)</span> para una muestra de datos <span class="math notranslate nohighlight">\(\theta\)</span>. Ten en cuenta que una rotación de un solo qubit se define como <span class="math notranslate nohighlight">\(RP(\phi) = \exp(- i [\phi/2] P)\)</span> para <span class="math notranslate nohighlight">\(P \in {X, Y, Z}\)</span>.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[6]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qiskit.tools.visualization</span> <span class="kn">import</span> <span class="n">circuit_drawer</span>

<span class="n">circuit_drawer</span><span class="p">(</span>
    <span class="n">fm</span><span class="o">.</span><span class="n">construct_circuit</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x_train</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">parameters</span><span class="o">=</span><span class="n">initial_point</span><span class="p">),</span>
    <span class="n">output</span><span class="o">=</span><span class="s2">&quot;text&quot;</span><span class="p">,</span>
    <span class="n">fold</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[6]:
</pre></div>
</div>
<div class="output_area rendered_html docutils container">
<pre style="word-wrap: normal;white-space: pre;background: #fff0;line-height: 1.1;font-family: &quot;Courier New&quot;,Courier,monospace">     ┌──────────┐   ┌──────────────┐ ┌────────────┐
q_0: ┤ Ry(-0.1) ├─■─┤ Rz(-0.38383) ├─┤ Rx(3.3378) ├─────────────────────────────────────────────────
     ├──────────┤ │ └──────────────┘ └────────────┘┌──────────────┐ ┌──────────────┐
q_1: ┤ Ry(-0.1) ├─┼────────────────────────■───────┤ Rz(-0.11811) ├─┤ Rx(-0.20449) ├────────────────
     ├──────────┤ │                        │       └──────────────┘ └┬────────────┬┘┌─────────────┐
q_2: ┤ Ry(-0.1) ├─■────────■───────────────┼──────────────■──────────┤ Rz(3.4802) ├─┤ Rx(0.15495) ├─
     ├──────────┤          │               │              │         ┌┴────────────┤ ├─────────────┴┐
q_3: ┤ Ry(-0.1) ├─■────────┼───────────────┼──────────────■─────────┤ Rz(0.34764) ├─┤ Rx(-0.54085) ├
     ├──────────┤ │        │               │                        ├─────────────┤ ├──────────────┤
q_4: ┤ Ry(-0.1) ├─■────────┼───────────────■──────────────■─────────┤ Rz(0.34312) ├─┤ Rx(-0.14015) ├
     ├──────────┤          │        ┌─────────────┐       │        ┌┴─────────────┴┐└──────────────┘
q_5: ┤ Ry(-0.1) ├──────────■────────┤ Rz(0.51497) ├───────┼────────┤ Rx(-0.029293) ├────────────────
     ├──────────┤                   └─────────────┘       │        └┬──────────────┤┌─────────────┐
q_6: ┤ Ry(-0.1) ├─────────────────────────────────────────■─────────┤ Rz(-0.42725) ├┤ Rx(0.44115) ├─
     └──────────┘                                                   └──────────────┘└─────────────┘ </pre></div>
</div>
<p>A continuación, establecemos los valores para la penalización del margen suave de la SVM <code class="docutils literal notranslate"><span class="pre">C</span></code> y el número de iteraciones de SPSA <code class="docutils literal notranslate"><span class="pre">maxiters</span></code> que usamos para alinear el kernel cuántico.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[7]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">C</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># SVM soft-margin penalty</span>
<span class="n">maxiters</span> <span class="o">=</span> <span class="mi">10</span>  <span class="c1"># number of SPSA iterations</span>
</pre></div>
</div>
</div>
<p>Finalmente, decidimos cómo mapear los qubits virtuales de nuestro grafo del problema a los qubits físicos del hardware. Por ejemplo, en el problema de 7 qubits, podemos asignar directamente los qubits virtuales <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">4,</span> <span class="pre">5,</span> <span class="pre">6]</span></code> a los qubits físicos <code class="docutils literal notranslate"><span class="pre">[10,</span> <span class="pre">11,</span> <span class="pre">12,</span> <span class="pre">13,</span> <span class="pre">14,</span> <span class="pre">15,</span> <span class="pre">16]</span></code> del dispositivo. Esto nos permite evitar la introducción de compuertas SWAP para qubits que no están conectados, lo que puede aumentar la profundidad del circuito.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[8]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">initial_layout</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">16</span><span class="p">]</span>  <span class="c1"># see figure above for the 7-qubit graph</span>
<span class="c1"># initial_layout = [9, 8, 11, 14, 16, 19, 22, 25, 24, 23]       # see figure above for the 10-qubit graph</span>
</pre></div>
</div>
</div>
</section>
<section id="3.-Configurar-y-ejecutar-el-programa">
<h2>3. Configurar y ejecutar el programa<a class="headerlink" href="#3.-Configurar-y-ejecutar-el-programa" title="Permalink to this heading">¶</a></h2>
<p>Estamos casi listos para ejecutar el programa. Primero, echemos un vistazo a los metadatos del programa, que incluyen una descripción de los parámetros de entrada y sus valores predeterminados.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[9]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">service</span><span class="o">.</span><span class="n">program</span><span class="p">(</span><span class="s2">&quot;quantum-kernel-alignment&quot;</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
quantum-kernel-alignment:
  Name: quantum-kernel-alignment
  Description: Quantum kernel alignment algorithm that learns, on a given dataset, a quantum kernel maximizing the SVM classification margin.
  Creation date: 2021-05-06T14:56:53Z
  Update date: 2021-11-10T17:10:19.159734Z
  Max execution time: 28800
  Input parameters:
    Properties:
        - feature_map:
            Type: object
            Description: An instance of FeatureMap in dictionary format used to map classical data into a quantum state space.
            Required: True
        - initial_layout:
            Type: [&#39;null&#39;, &#39;array&#39;, &#39;object&#39;]
            Default: null
            Description: Initial position of virtual qubits on the physical qubits of the quantum device. Default is None.
            Required: False
        - initial_kernel_parameters:
            Type: array
            Description: Initial parameters of the quantum kernel. If not specified, an array of randomly generated numbers is used. This is a numpy array.
            Required: False
        - C:
            Type: number
            Default: 1
            Description: Penalty parameter for the soft-margin support vector machine. Default is 1.
            Required: False
        - data:
            Type: array
            Description: NxD array of training data, where N is the number of samples and D is the feature dimension. This is a numpy array.
            Required: True
        - labels:
            Type: array
            Description: Nx1 array of +/-1 labels of the N training samples. This is a numpy array.
            Required: True
        - maxiters:
            Type: integer
            Default: 1
            Description: Number of SPSA optimization steps. Default is 1.
            Required: False
  Interim results:
    none
  Returns:
    Properties:
        - aligned_kernel_matrix:
            Type: array
            Description: The aligned quantum kernel matrix evaluated with the optimized kernel parameters on the training data. This is a numpy array.
            Required: False
        - aligned_kernel_parameters:
            Type: array
            Description: The optimized kernel parameters found from quantum kernel alignment. This is a numpy array.
            Required: False
</pre></div></div>
</div>
<p>Vemos que este programa tiene varios parámetros de entrada, que configuraremos a continuación. Para ejecutar el programa, configuraremos sus dos componentes principales: <code class="docutils literal notranslate"><span class="pre">inputs</span></code> (los parámetros de entrada de los metadatos del programa) y <code class="docutils literal notranslate"><span class="pre">options</span></code> (el backend cuántico). También definiremos una función de devolución de llamada para que los resultados intermedios del algoritmo se impriman a medida que se ejecuta el programa. Ten en cuenta que cada paso del algoritmo para la configuración que hemos seleccionado aquí toma aproximadamente 11 minutos.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[10]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">interim_result_callback</span><span class="p">(</span><span class="n">job_id</span><span class="p">,</span> <span class="n">interim_result</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;interim result: </span><span class="si">{</span><span class="n">interim_result</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[12]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">program_inputs</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;feature_map&quot;</span><span class="p">:</span> <span class="n">fm</span><span class="p">,</span>
    <span class="s2">&quot;data&quot;</span><span class="p">:</span> <span class="n">x_train</span><span class="p">,</span>
    <span class="s2">&quot;labels&quot;</span><span class="p">:</span> <span class="n">y_train</span><span class="p">,</span>
    <span class="s2">&quot;initial_kernel_parameters&quot;</span><span class="p">:</span> <span class="n">initial_point</span><span class="p">,</span>
    <span class="s2">&quot;maxiters&quot;</span><span class="p">:</span> <span class="n">maxiters</span><span class="p">,</span>
    <span class="s2">&quot;C&quot;</span><span class="p">:</span> <span class="n">C</span><span class="p">,</span>
    <span class="s2">&quot;initial_layout&quot;</span><span class="p">:</span> <span class="n">initial_layout</span><span class="p">,</span>
<span class="p">}</span>

<span class="n">options</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;backend_name&quot;</span><span class="p">:</span> <span class="n">backend</span><span class="o">.</span><span class="n">name</span><span class="p">}</span>

<span class="n">job</span> <span class="o">=</span> <span class="n">service</span><span class="o">.</span><span class="n">run</span><span class="p">(</span>
    <span class="n">program_id</span><span class="o">=</span><span class="s2">&quot;quantum-kernel-alignment&quot;</span><span class="p">,</span>
    <span class="n">options</span><span class="o">=</span><span class="n">options</span><span class="p">,</span>
    <span class="n">inputs</span><span class="o">=</span><span class="n">program_inputs</span><span class="p">,</span>
    <span class="n">callback</span><span class="o">=</span><span class="n">interim_result_callback</span><span class="p">,</span>
<span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">job</span><span class="o">.</span><span class="n">job_id</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">job</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
c7ffvf20jbtu2e0f4ckg
interim result: {&#39;cost&#39;: 10.638621575044311, &#39;kernel_parameters&#39;: array([0.14377543])}

interim result: {&#39;cost&#39;: 10.607880279846587, &#39;kernel_parameters&#39;: array([0.23459471])}

interim result: {&#39;cost&#39;: 10.354563275777544, &#39;kernel_parameters&#39;: array([0.33656085])}

interim result: {&#39;cost&#39;: 9.918023227764865, &#39;kernel_parameters&#39;: array([0.45528513])}

interim result: {&#39;cost&#39;: 9.160734304693074, &#39;kernel_parameters&#39;: array([0.58508042])}

interim result: {&#39;cost&#39;: 8.256924450332054, &#39;kernel_parameters&#39;: array([0.70784733])}

interim result: {&#39;cost&#39;: 7.331773657686416, &#39;kernel_parameters&#39;: array([0.81852789])}

interim result: {&#39;cost&#39;: 6.578431435591056, &#39;kernel_parameters&#39;: array([0.91250701])}

interim result: {&#39;cost&#39;: 6.015379867635877, &#39;kernel_parameters&#39;: array([0.97653913])}

interim result: {&#39;cost&#39;: 5.691687363255383, &#39;kernel_parameters&#39;: array([1.03604491])}

</pre></div></div>
</div>
</section>
<section id="4.-Recuperar-los-resultados-del-programa">
<h2>4. Recuperar los resultados del programa<a class="headerlink" href="#4.-Recuperar-los-resultados-del-programa" title="Permalink to this heading">¶</a></h2>
<p>Ahora que hemos ejecutado el programa, podemos recuperar la salida, que es el parámetro del kernel alineado y la matriz del kernel alineado. Grafiquemos también esta matriz del kernel (restaremos la diagonal para mostrar el contraste entre las entradas restantes). Se espera que la matriz del kernel tenga una estructura de bloque diagonal. Esto refleja el hecho de que el núcleo mapea los datos de entrada de manera efectiva a solo dos estados (módulo al pequeño ruido que agregamos a los datos; recuerda la discusión anterior). Es decir, los datos en la misma clase lateral (misma etiqueta de clase) tienen una superposición mayor que los datos de diferentes clases laterales.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[13]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;aligned_kernel_parameters: </span><span class="si">{</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;aligned_kernel_parameters&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">from</span> <span class="nn">pylab</span> <span class="kn">import</span> <span class="n">cm</span>

<span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s2">&quot;font.size&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">20</span>
<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span>
    <span class="n">result</span><span class="p">[</span><span class="s2">&quot;aligned_kernel_matrix&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">num_train</span><span class="p">),</span>
    <span class="n">cmap</span><span class="o">=</span><span class="n">cm</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s2">&quot;bwr&quot;</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span>
<span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
aligned_kernel_parameters: [1.03604491]
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/tutorials_qka_23_1.png" src="../_images/tutorials_qka_23_1.png" />
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[18]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">qiskit.tools.jupyter</span>

<span class="o">%</span><span class="k">qiskit_copyright</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area rendered_html docutils container">
<div style='width: 100%; background-color:#d5d9e0;padding-left: 10px; padding-bottom: 10px; padding-right: 10px; padding-top: 5px'><h3>This code is a part of Qiskit</h3><p>&copy; Copyright IBM 2017, 2022.</p><p>This code is licensed under the Apache License, Version 2.0. You may<br>obtain a copy of this license in the LICENSE.txt file in the root directory<br> of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.<p>Any modifications or derivative works of this code must retain this<br>copyright notice, and modified files need to carry a notice indicating<br>that they have been altered from the originals.</p></div></div>
</div>
</section>
</section>


             </article>
             
            </div>
            <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="vqe.html" class="btn btn-neutral float-right" title="VQE" accesskey="n" rel="next">Next <img src="../_static/images/chevron-right-orange.svg" class="next-page"></a>
      
      
        <a href="sample_expval_program/qiskit_runtime_expval_program.html" class="btn btn-neutral" title="Programa de Valor Esperado Personalizado para Qiskit Runtime" accesskey="p" rel="prev"><img src="../_static/images/chevron-right-orange.svg" class="previous-page"> Previous</a>
      
    </div>
  

  

    <hr>

  

  <div role="contentinfo">
    <p>
        &copy; Copyright 2022, Qiskit Development Team.
      Actualizado por última vez en 2022/07/16.

    </p>
  </div>
    
      <div>
        Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
      </div>
     

</footer>

          </div>
        </div>

        <div class="pytorch-content-right" id="pytorch-content-right">
          <div class="pytorch-right-menu" id="pytorch-right-menu">
            <div class="pytorch-side-scroll" id="pytorch-side-scroll-right">
              <ul>
<li><a class="reference internal" href="#">Alineación del Kernel Cuántico con Qiskit Runtime</a></li>
<li><a class="reference internal" href="#Carga-tu-cuenta-y-obtén-el-backend-cuántico">Carga tu cuenta y obtén el backend cuántico</a></li>
<li><a class="reference internal" href="#Invocar-el-programa-de-Alineación-de-Kernel-Cuántico">Invocar el programa de Alineación de Kernel Cuántico</a><ul>
<li><a class="reference internal" href="#1.-Preparar-el-conjunto-de-datos">1. Preparar el conjunto de datos</a></li>
<li><a class="reference internal" href="#2.-Configurar-el-algoritmo-QKA">2. Configurar el algoritmo QKA</a></li>
<li><a class="reference internal" href="#3.-Configurar-y-ejecutar-el-programa">3. Configurar y ejecutar el programa</a></li>
<li><a class="reference internal" href="#4.-Recuperar-los-resultados-del-programa">4. Recuperar los resultados del programa</a></li>
</ul>
</li>
</ul>

            </div>
          </div>
        </div>
      </section>
    </div>

  

     
       <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
         <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
         <script src="../_static/jquery.js"></script>
         <script src="../_static/underscore.js"></script>
         <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
         <script src="../_static/doctools.js"></script>
         <script src="../_static/thebelab-helper.js"></script>
         <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
         <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.20.1/dist/embed-amd.js"></script>
         <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
         <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
         <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
     

  

  <script type="text/javascript" src="../_static/js/vendor/popper.min.js"></script>
  <script type="text/javascript" src="../_static/js/vendor/bootstrap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/list.js/1.5.0/list.min.js"></script>
  <script type="text/javascript" src="../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

  <div>
    <br>
  </div>

  <!-- Begin Mobile Menu -->

  <div class="mobile-main-menu">
    <div class="container-fluid">
      <div class="container">
        <div class="mobile-main-menu-header-container">
          <a class="header-logo" href="https://qiskit.org/" aria-label="PyTorch"></a>
          <a class="main-menu-close-button" href="#" data-behavior="close-mobile-menu"></a>
        </div>
      </div>
    </div>

    <div class="mobile-main-menu-links-container">
      <div class="main-menu">
        <ul>
          <li>
            <a href="../getting_started.html">Getting Started</a>
          </li>
          <li>
            <a href="../tutorials.html">Tutorials</a>
          </li>
          <li>
            <a href="https://qiskit.org/documentation/partners/">Qiskit Providers</a>
          </li>
          <br>
          <li class="resources-mobile-menu-title">
            Applications
          </li>
          <ul class="resources-mobile-menu-items">
            <li>
              <a href="https://qiskit.org/documentation/machine-learning/">Machine learning</a>
            </li>

            <li>
              <a href="https://qiskit.org/documentation/nature/">Nature</a>
            </li>

            <li>
              <a href="https://qiskit.org/documentation/finance/">Finance</a>
            </li>

            <li>
              <a href="https://qiskit.org/documentation/optimization/">Optimization</a>
            </li>
          </ul>

          <br>

          <li class="resources-mobile-menu-title">
            Resources
          </li>

          <ul class="resources-mobile-menu-items">
            <li>
              <a href="https://qiskit.slack.com">Slack support</a>
            </li>
          </ul>
          <br>
        </ul>
      </div>
    </div>
  </div>

  <!-- End Mobile Menu -->

  <script type="text/javascript" src="../_static/js/vendor/anchor.min.js"></script>

  <script type="text/javascript">
    $(document).ready(function() {
      mobileMenu.bind();
      mobileTOC.bind();
      pytorchAnchors.bind();
      sideMenus.bind();
      scrollToAnchor.bind();
      highlightNavigation.bind();
      mainMenuDropdown.bind();
      filterTags.bind();

      // Add class to links that have code blocks, since we cannot create links in code blocks
      $("article.pytorch-article a span.pre").each(function(e) {
        $(this).closest("a").addClass("has-code");
      });
    })
  </script>
</body>
</html>